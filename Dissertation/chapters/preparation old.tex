% 	What did before starting to program. 
% 	Software engineering planning etc.
% *! Show that I understood the task and analysed it
% *! Good introduction to technical background, coherent discussion and sensible planning
% * Requirements analysis
% * Cite any new programming languages and systems which had to be learnt
% * Mention complicated theories or algorithms which required understanding

% ************
% Should have: 
% 	intro
% 	content
% 	summary
% ************

% Allowed roughly 1200 words
\section{Preparation}
% Intro:
%   Writing what I did to prepare


In this chapter I will briefly describe how I prepared for my project, what led to the design decisions I made and how they influenced the final outcome.

\mbox{} % Empty line

% Content
%   How did I prepare
%     Requirements
%       Fit into into existing services? (webservice)

I had two goals for my project:

Firstly I wanted my search engine to be a program that would be run by the providers of online social networks alongside the installations of their online social networks.
By having multiple online social networks run the program, the burden of keeping the search network I provide operational gets evenly distributed between the online social networks participating in it. 

Secondly I wanted to make it easy for the creators of the online social networks to integrate my service into their software.
I decided to do this by exposing my service through an HTTP based API because I know from experience that web developers find that convenient. 

% 
%     Read through different DHT's
%       Decided on three
%         Cut down to two, why?

I wanted to evaluate how successfully one can use Distributed Hash Tables as the backend datastore for a search engine of this particular kind. Bear in mind that my search engine would not be aimed at searching for arbitrary terms in a collection of documents, but rather well defined user profile records. 

Using Distributed Hash Tables immediately presents benefits and drawbacks: 

The benefits are that Distributed Hash Tables promise key-lookups involving only a subset of the nodes in the network. The subset is proportional to the logarithm of the total number of nodes. 

If you are careful when assigning keys to data items so that they are uniformly spread across the keyspace, the data and computational workload gets evenly spread out between the nodes participating in the network. Also a plus, and what makes using a distributed hash table an excellent idea, is that it allows nodes to join and leave at will. This is extremely important for a search network spanning multiple independent online social networks, each potentially being run in multiple locations by independent providers. The social networks are also free to join as they themselves see fit, and there is no central authority that can guarantee computational resources being available or for that matter staying available.

A big drawback is that distributed hash tables are key-value stores. It is not immediately obvious how one can efficiently search across data stored under keys unless the keys are known. I arrived at a solution that in my opinion circumvents this shortcoming quite elegantly. I will discuss it further in the implementation chapter.

\begin{figure}[!htb]
\begin{center}
	\includegraphics[width=0.9\linewidth]{illustrations/KeySpace.eps}
\caption{This diagram illustrates the keyspace of a Distributed Hash Table network. The nodes in the network are shown as dots. The grey line show the nodes involved in a particular key-lookup.}
\label{keySpace}
\end{center}
\end{figure}

During my preparation I evaluated different distributed hash tables. The initial plan was to implement Chord, Pastry and Kademilia, and to compare their relative benefits and drawbacks. 

Chord and Pastry differ in the way the approach routing. While Chord keeps its routing tables as simple as possible, Pastry adds an additionally implementation specific proximity metric that favours closer nodes when routing. Implementing both Chord and Pastry allows me to evaluate the effectiveness of such heuristics. Upon realising Kademilia only differs from Chord in ways Pastry already differs, I decided to drop it as it superflous. The direct benefit of this decisions is that it allowed more time for compare Chord and Pastry and evaluate if Distributed Hash Tables can be successful datastores for my particular kind of search engines.

%     Learned Erlang
%       Got to know standard libraries and frameworks (OTP)
%       webmachine
%       rebar
%       how to do testing

\mbox{}

Programming distributed systems is one of the key strengths of the programming language Erlang. Additionally it has built in support through its standard libraries for writing fault tolerant systems wit hot code swapping. My project being highly distributed in nature made Erlang a natural choice. Using Erlang let me spend more time on the core algorithms instead of having to reimplement infrastructure for working with distributed systems on top of another language.

I spent considerable time learning Erlang, its libraries and frameworks, and also how to use third party libraries for creating webservices through Erlang with Webmachine, and compiling and analysing code with rebar.

% 
% Summary:
%   Which steps I took

\mbox{} % Insert an empty line

In this chapter I discussed how I decided that my project should expose its functionality through an HTTP API, why I chose to use Distributed Hash Tables, and why Erlang was chosen as the language of implementation.
In the next chapter I will discuss the implementation of my project.
