<html>
<head><title>.eunit/webmachine_request.COVER.html</title></head><body bgcolor=white text=black>
<pre>
File generated from /Users/seb/Documents/part2project/app/deps/webmachine/.eunit/webmachine_request.erl by COVER 2010-10-28 at 14:19:55

****************************************************************************

        |  %% @author Justin Sheehy &lt;justin@basho.com&gt;
        |  %% @author Andy Gross &lt;andy@basho.com&gt;
        |  %% @copyright 2007-2009 Basho Technologies
        |  %% Based on mochiweb_request.erl, which is Copyright 2007 Mochi Media, Inc.
        |  %%
        |  %%    Licensed under the Apache License, Version 2.0 (the "License");
        |  %%    you may not use this file except in compliance with the License.
        |  %%    You may obtain a copy of the License at
        |  %%
        |  %%        http://www.apache.org/licenses/LICENSE-2.0
        |  %%
        |  %%    Unless required by applicable law or agreed to in writing, software
        |  %%    distributed under the License is distributed on an "AS IS" BASIS,
        |  %%    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        |  %%    See the License for the specific language governing permissions and
        |  %%    limitations under the License.
        |  
        |  %% @doc Webmachine HTTP Request Abstraction.
        |  
        |  -module(webmachine_request, [ReqState]).
        |  -author('Justin Sheehy &lt;justin@basho.com&gt;').
        |  -author('Andy Gross &lt;andy@basho.com&gt;').
        |  
        |  -export([get_peer/0]). % used in initialization
        |  -export([call/1]). % internal switching interface, used by wrcall
        |  
        |  % actual interface for resource functions
        |  -export([
        |           trim_state/0,
        |           get_reqdata/0,
        |           set_reqdata/1,
        |           socket/0,
        |           method/0,
        |           version/0,
        |           disp_path/0,
        |           path/0,
        |           raw_path/0,
        |           get_req_header/1,
        |           req_headers/0,
        |           req_body/1,
        |           stream_req_body/1,
        |           headers/0,
        |           resp_headers/0,
        |           out_headers/0,
        |           get_out_header/1,
        |           has_out_header/1,
        |           peer/0,
        |           get_header_value/1,
        |           add_response_header/2,
        |           add_response_headers/1,
        |           remove_response_header/1,
        |           merge_response_headers/1,
        |           append_to_response_body/1,
        |           send_response/1,
        |           response_code/0,
        |           set_response_code/1,
        |           set_resp_body/1,
        |           response_body/0,
        |           has_response_body/0,
        |           do_redirect/0,
        |           resp_redirect/0,
        |           set_metadata/2,
        |           get_metadata/1,
        |           get_path_info/0,
        |           get_path_info/1,
        |           load_dispatch_data/6,
        |           get_path_tokens/0,
        |           get_app_root/0,
        |           parse_cookie/0,
        |           get_cookie_value/1,
        |           parse_qs/0,
        |           get_qs_value/1,
        |           get_qs_value/2,
        |           range/0,
        |           log_data/0
        |          ]).
        |  
        |  -include("webmachine_logger.hrl").
        |  -include_lib("include/wm_reqstate.hrl").
        |  -include_lib("include/wm_reqdata.hrl").
        |  -include_lib("mochiweb/include/internal.hrl").
        |  
        |  -define(WMVSN, "1.7.3").
        |  -define(QUIP, "participate in the frantic").
        |  -define(IDLE_TIMEOUT, infinity).
        |  
        |  trim_state() -&gt;
<font color=red>     0..|      TrimData = (ReqState#wm_reqstate.reqdata)#wm_reqdata{wm_state='WMSTATE'},</font>
<font color=red>     0..|      webmachine_request:new(ReqState#wm_reqstate{reqdata=TrimData}).</font>
        |  
        |  get_peer() -&gt;
<font color=red>     0..|      case ReqState#wm_reqstate.peer of</font>
        |      undefined -&gt;
<font color=red>     0..|          PeerName = case ReqState#wm_reqstate.socket of</font>
<font color=red>     0..|              {ssl,SslSocket} -&gt; ssl:peername(SslSocket);</font>
<font color=red>     0..|              _ -&gt; inet:peername(ReqState#wm_reqstate.socket)</font>
        |          end,
<font color=red>     0..|          Peer = peer_from_peername(PeerName),</font>
<font color=red>     0..|          NewReqState = ReqState#wm_reqstate{peer=Peer},</font>
<font color=red>     0..|          {Peer, NewReqState};</font>
        |      _ -&gt;
<font color=red>     0..|          {ReqState#wm_reqstate.peer, ReqState}</font>
        |      end.
        |  
        |  peer_from_peername({ok, {Addr={10, _, _, _}, _Port}}) -&gt;  
<font color=red>     0..|      x_peername(inet_parse:ntoa(Addr));</font>
        |  peer_from_peername({ok, {Addr={172, Second, _, _}, _Port}}) when (Second &gt; 15) andalso (Second &lt; 32) -&gt;
<font color=red>     0..|      x_peername(inet_parse:ntoa(Addr));</font>
        |  peer_from_peername({ok, {Addr={192, 168, _, _}, _Port}}) -&gt;
<font color=red>     0..|      x_peername(inet_parse:ntoa(Addr));</font>
        |  peer_from_peername({ok, {{127, 0, 0, 1}, _Port}}) -&gt;
<font color=red>     0..|      x_peername("127.0.0.1");</font>
        |  peer_from_peername({ok, {Addr, _Port}}) -&gt;
<font color=red>     0..|      inet_parse:ntoa(Addr).</font>
        |  
        |  x_peername(Default) -&gt;
<font color=red>     0..|      case get_header_value("x-forwarded-for") of</font>
        |      {undefined, _} -&gt;
<font color=red>     0..|          Default;</font>
        |      {Hosts, _} -&gt;
<font color=red>     0..|          string:strip(lists:last(string:tokens(Hosts, ",")))</font>
        |      end.
        |  
<font color=red>     0..|  call(socket) -&gt; {ReqState#wm_reqstate.socket,ReqState};</font>
<font color=red>     0..|  call(get_reqdata) -&gt; {ReqState#wm_reqstate.reqdata, ReqState};</font>
<font color=red>     0..|  call({set_reqdata, RD}) -&gt; {ok, ReqState#wm_reqstate{reqdata=RD}};</font>
<font color=red>     0..|  call(method) -&gt; {wrq:method(ReqState#wm_reqstate.reqdata), ReqState};</font>
<font color=red>     0..|  call(version) -&gt; {wrq:version(ReqState#wm_reqstate.reqdata), ReqState};</font>
<font color=red>     0..|  call(raw_path) -&gt; {wrq:raw_path(ReqState#wm_reqstate.reqdata), ReqState};</font>
<font color=red>     0..|  call(req_headers) -&gt; {wrq:req_headers(ReqState#wm_reqstate.reqdata), ReqState};</font>
        |  call({req_body, MaxRecvBody}) -&gt;
<font color=red>     0..|      case ReqState#wm_reqstate.bodyfetch of</font>
        |          stream -&gt;
<font color=red>     0..|              {stream_conflict, ReqState};</font>
        |          standard -&gt;
<font color=red>     0..|              {ReqState#wm_reqstate.reqbody, ReqState};</font>
        |          undefined -&gt;
<font color=red>     0..|              RD=(ReqState#wm_reqstate.reqdata)#wm_reqdata{</font>
        |                   max_recv_body=MaxRecvBody},
<font color=red>     0..|              NewReqState=ReqState#wm_reqstate{reqdata=RD},</font>
<font color=red>     0..|              NewBody = case get(req_body) of</font>
        |                  undefined -&gt;
<font color=red>     0..|                      NewB = do_recv_body(NewReqState),</font>
<font color=red>     0..|                      put(req_body, NewB),</font>
<font color=red>     0..|                      NewB;</font>
<font color=red>     0..|                  B -&gt; B</font>
        |              end,
<font color=red>     0..|              NewRD = RD#wm_reqdata{req_body=NewBody},</font>
<font color=red>     0..|              {NewBody, NewReqState#wm_reqstate{</font>
        |                          bodyfetch=standard,reqdata=NewRD,reqbody=NewBody}}
        |      end;
        |  call({stream_req_body, MaxHunk}) -&gt;
<font color=red>     0..|      case ReqState#wm_reqstate.bodyfetch of</font>
        |          standard -&gt;
<font color=red>     0..|              {stream_conflict, ReqState};</font>
        |          _ -&gt;
<font color=red>     0..|              {recv_stream_body(ReqState, MaxHunk),</font>
        |               ReqState#wm_reqstate{bodyfetch=stream}}
        |      end;
        |  call(resp_headers) -&gt;
<font color=red>     0..|      {wrq:resp_headers(ReqState#wm_reqstate.reqdata), ReqState};</font>
        |  call(resp_redirect) -&gt;
<font color=red>     0..|      {wrq:resp_redirect(ReqState#wm_reqstate.reqdata), ReqState};</font>
        |  call({get_resp_header, HdrName}) -&gt;
<font color=red>     0..|      Reply = mochiweb_headers:get_value(HdrName,</font>
        |                  wrq:resp_headers(ReqState#wm_reqstate.reqdata)),
<font color=red>     0..|      {Reply, ReqState};</font>
        |  call(get_path_info) -&gt;
<font color=red>     0..|      PropList = dict:to_list(wrq:path_info(ReqState#wm_reqstate.reqdata)),</font>
<font color=red>     0..|      {PropList, ReqState};</font>
        |  call({get_path_info, Key}) -&gt;
<font color=red>     0..|      {wrq:path_info(Key, ReqState#wm_reqstate.reqdata), ReqState};</font>
<font color=red>     0..|  call(peer) -&gt; get_peer();</font>
<font color=red>     0..|  call(range) -&gt; get_range();</font>
        |  call(response_code) -&gt;
<font color=red>     0..|      {wrq:response_code(ReqState#wm_reqstate.reqdata), ReqState};</font>
<font color=red>     0..|  call(app_root) -&gt; {wrq:app_root(ReqState#wm_reqstate.reqdata), ReqState};</font>
<font color=red>     0..|  call(disp_path) -&gt; {wrq:disp_path(ReqState#wm_reqstate.reqdata), ReqState};</font>
<font color=red>     0..|  call(path) -&gt; {wrq:path(ReqState#wm_reqstate.reqdata), ReqState};</font>
        |  call({get_req_header, K}) -&gt;
<font color=red>     0..|      {wrq:get_req_header(K, ReqState#wm_reqstate.reqdata), ReqState};</font>
        |  call({set_response_code, Code}) -&gt;
<font color=red>     0..|      {ok, ReqState#wm_reqstate{reqdata=wrq:set_response_code(</font>
        |                                       Code, ReqState#wm_reqstate.reqdata)}};
        |  call({set_resp_header, K, V}) -&gt;
<font color=red>     0..|      {ok, ReqState#wm_reqstate{reqdata=wrq:set_resp_header(</font>
        |                                       K, V, ReqState#wm_reqstate.reqdata)}};
        |  call({set_resp_headers, Hdrs}) -&gt;
<font color=red>     0..|      {ok, ReqState#wm_reqstate{reqdata=wrq:set_resp_headers(</font>
        |                                       Hdrs, ReqState#wm_reqstate.reqdata)}};
        |  call({remove_resp_header, K}) -&gt;
<font color=red>     0..|      {ok, ReqState#wm_reqstate{reqdata=wrq:remove_resp_header(</font>
        |                                       K, ReqState#wm_reqstate.reqdata)}};
        |  call({merge_resp_headers, Hdrs}) -&gt;
<font color=red>     0..|      {ok, ReqState#wm_reqstate{reqdata=wrq:merge_resp_headers(</font>
        |                                       Hdrs, ReqState#wm_reqstate.reqdata)}};
        |  call({append_to_response_body, Data}) -&gt;
<font color=red>     0..|      {ok, ReqState#wm_reqstate{reqdata=wrq:append_to_response_body(</font>
        |                                       Data, ReqState#wm_reqstate.reqdata)}};
        |  call({set_disp_path, P}) -&gt;
<font color=red>     0..|      {ok, ReqState#wm_reqstate{reqdata=wrq:set_disp_path(</font>
        |                                       P, ReqState#wm_reqstate.reqdata)}};
        |  call(do_redirect) -&gt;
<font color=red>     0..|      {ok, ReqState#wm_reqstate{</font>
        |             reqdata=wrq:do_redirect(true, ReqState#wm_reqstate.reqdata)}};
        |  call({send_response, Code}) -&gt;
<font color=red>     0..|      {Reply, NewState} = </font>
        |          case Code of
        |              200 -&gt;
<font color=red>     0..|                  send_ok_response();</font>
        |              _ -&gt;
<font color=red>     0..|                  send_response(Code)</font>
        |          end,
<font color=red>     0..|      LogData = NewState#wm_reqstate.log_data,</font>
<font color=red>     0..|      NewLogData = LogData#wm_log_data{finish_time=now()},</font>
<font color=red>     0..|      {Reply, NewState#wm_reqstate{log_data=NewLogData}};</font>
<font color=red>     0..|  call(resp_body) -&gt; {wrq:resp_body(ReqState#wm_reqstate.reqdata), ReqState};</font>
        |  call({set_resp_body, Body}) -&gt;
<font color=red>     0..|      {ok, ReqState#wm_reqstate{reqdata=wrq:set_resp_body(Body,</font>
        |                                         ReqState#wm_reqstate.reqdata)}};
        |  call(has_resp_body) -&gt;
<font color=red>     0..|      Reply = case wrq:resp_body(ReqState#wm_reqstate.reqdata) of</font>
<font color=red>     0..|                  undefined -&gt; false;</font>
<font color=red>     0..|                  &lt;&lt;&gt;&gt; -&gt; false;</font>
<font color=red>     0..|                  _ -&gt; true</font>
        |              end,
<font color=red>     0..|      {Reply, ReqState};</font>
        |  call({get_metadata, Key}) -&gt;
<font color=red>     0..|      Reply = case dict:find(Key, ReqState#wm_reqstate.metadata) of</font>
<font color=red>     0..|                  {ok, Value} -&gt; Value;</font>
<font color=red>     0..|                  error -&gt; undefined</font>
        |              end,
<font color=red>     0..|      {Reply, ReqState};</font>
        |  call({set_metadata, Key, Value}) -&gt;
<font color=red>     0..|      NewDict = dict:store(Key, Value, ReqState#wm_reqstate.metadata),</font>
<font color=red>     0..|      {ok, ReqState#wm_reqstate{metadata=NewDict}};</font>
<font color=red>     0..|  call(path_tokens) -&gt; {wrq:path_tokens(ReqState#wm_reqstate.reqdata), ReqState};</font>
<font color=red>     0..|  call(req_cookie) -&gt; {wrq:req_cookie(ReqState#wm_reqstate.reqdata), ReqState};</font>
<font color=red>     0..|  call(req_qs) -&gt; {wrq:req_qs(ReqState#wm_reqstate.reqdata), ReqState};</font>
        |  call({load_dispatch_data, PathProps, HostTokens, Port,
        |        PathTokens, AppRoot, DispPath}) -&gt;
<font color=red>     0..|      PathInfo = dict:from_list(PathProps),</font>
<font color=red>     0..|      NewState = ReqState#wm_reqstate{reqdata=wrq:load_dispatch_data(</font>
        |                          PathInfo,HostTokens,Port,PathTokens,AppRoot,
        |                          DispPath,ReqState#wm_reqstate.reqdata)},
<font color=red>     0..|      {ok, NewState};</font>
<font color=red>     0..|  call(log_data) -&gt; {ReqState#wm_reqstate.log_data, ReqState};</font>
<font color=red>     0..|  call(notes) -&gt; {wrq:get_notes(ReqState#wm_reqstate.reqdata), ReqState}.</font>
        |  
        |  get_header_value(K) -&gt;
<font color=red>     0..|      {wrq:get_req_header(K, ReqState#wm_reqstate.reqdata), ReqState}.</font>
        |  
        |  get_outheader_value(K) -&gt;
<font color=red>     0..|      {mochiweb_headers:get_value(K,</font>
        |        wrq:resp_headers(ReqState#wm_reqstate.reqdata)), ReqState}.
        |  
        |  send(Socket, Data) -&gt;
<font color=red>     0..|      case mochiweb_socket:send(Socket, iolist_to_binary(Data)) of</font>
<font color=red>     0..|          ok -&gt; ok;</font>
<font color=red>     0..|          {error,closed} -&gt; ok;</font>
<font color=red>     0..|          _ -&gt; exit(normal)</font>
        |      end.
        |  
<font color=red>     0..|  send_stream_body(Socket, X) -&gt; send_stream_body(Socket, X, 0).</font>
        |  send_stream_body(Socket, {&lt;&lt;&gt;&gt;, done}, SoFar) -&gt;
<font color=red>     0..|      send_chunk(Socket, &lt;&lt;&gt;&gt;),</font>
<font color=red>     0..|      SoFar;</font>
        |  send_stream_body(Socket, {Data, done}, SoFar) -&gt;
<font color=red>     0..|      Size = send_chunk(Socket, Data),</font>
<font color=red>     0..|      send_chunk(Socket, &lt;&lt;&gt;&gt;),</font>
<font color=red>     0..|      Size + SoFar;</font>
        |  send_stream_body(Socket, {&lt;&lt;&gt;&gt;, Next}, SoFar) -&gt;
<font color=red>     0..|      send_stream_body(Socket, Next(), SoFar);</font>
        |  send_stream_body(Socket, {[], Next}, SoFar) -&gt;
<font color=red>     0..|      send_stream_body(Socket, Next(), SoFar);</font>
        |  send_stream_body(Socket, {Data, Next}, SoFar) -&gt;
<font color=red>     0..|      Size = send_chunk(Socket, Data),</font>
<font color=red>     0..|      send_stream_body(Socket, Next(), Size + SoFar).</font>
        |  
        |  send_writer_body(Socket, {Encoder, Charsetter, BodyFun}) -&gt;
<font color=red>     0..|      put(bytes_written, 0),</font>
<font color=red>     0..|      Writer = fun(Data) -&gt;</font>
<font color=red>     0..|          Size = send_chunk(Socket, Encoder(Charsetter(Data))),</font>
<font color=red>     0..|          put(bytes_written, get(bytes_written) + Size),</font>
<font color=red>     0..|          Size</font>
        |      end,
<font color=red>     0..|      BodyFun(Writer),</font>
<font color=red>     0..|      send_chunk(Socket, &lt;&lt;&gt;&gt;),</font>
<font color=red>     0..|      get(bytes_written).</font>
        |  
        |  send_chunk(Socket, Data) -&gt;
<font color=red>     0..|      Size = iolist_size(Data),</font>
<font color=red>     0..|      send(Socket, mochihex:to_hex(Size)),</font>
<font color=red>     0..|      send(Socket, &lt;&lt;"\r\n"&gt;&gt;),</font>
<font color=red>     0..|      send(Socket, Data),</font>
<font color=red>     0..|      send(Socket, &lt;&lt;"\r\n"&gt;&gt;),</font>
<font color=red>     0..|      Size.</font>
        |  
        |  send_ok_response() -&gt;
<font color=red>     0..|      RD0 = ReqState#wm_reqstate.reqdata,</font>
<font color=red>     0..|      {Range, State} = get_range(),</font>
<font color=red>     0..|      case Range of</font>
        |          X when X =:= undefined; X =:= fail -&gt;
<font color=red>     0..|              send_response(200);</font>
        |          Ranges -&gt;
<font color=red>     0..|              {PartList, Size} = range_parts(RD0, Ranges),</font>
<font color=red>     0..|              case PartList of</font>
        |                  [] -&gt; %% no valid ranges
        |                      %% could be 416, for now we'll just return 200
<font color=red>     0..|                      send_response(200);</font>
        |                  PartList -&gt;
<font color=red>     0..|                      {RangeHeaders, RangeBody} = parts_to_body(PartList, Size),</font>
<font color=red>     0..|                      RespHdrsRD = wrq:set_resp_headers(</font>
        |                               [{"Accept-Ranges", "bytes"} | RangeHeaders], RD0),
<font color=red>     0..|                      RespBodyRD = wrq:set_resp_body(</font>
        |                                     RangeBody, RespHdrsRD),
<font color=red>     0..|                      NewState = State#wm_reqstate{reqdata=RespBodyRD},</font>
<font color=red>     0..|                      send_response(206, NewState)</font>
        |              end
        |      end.
        |  
<font color=red>     0..|  send_response(Code) -&gt; send_response(Code,ReqState).</font>
        |  send_response(Code, PassedState=#wm_reqstate{reqdata=RD}) -&gt;
<font color=red>     0..|      Body0 = wrq:resp_body(RD),</font>
<font color=red>     0..|      {Body,Length} = case Body0 of</font>
<font color=red>     0..|          {stream, StreamBody} -&gt; {{stream, StreamBody}, chunked};</font>
<font color=red>     0..|          {stream, Size, Fun} -&gt; {{stream, Fun(0, Size-1)}, chunked};</font>
<font color=red>     0..|          {writer, WriteBody} -&gt; {{writer, WriteBody}, chunked};</font>
<font color=red>     0..|          _ -&gt; {Body0, iolist_size([Body0])}</font>
        |      end,
<font color=red>     0..|      send(PassedState#wm_reqstate.socket,</font>
        |           [make_version(wrq:version(RD)),
        |            make_code(Code), &lt;&lt;"\r\n"&gt;&gt; | 
        |           make_headers(Code, Length, RD)]),
<font color=red>     0..|      FinalLength = case wrq:method(RD) of </font>
<font color=red>     0..|           'HEAD' -&gt; Length;</font>
        |           _ -&gt; 
<font color=red>     0..|              case Body of</font>
        |                  {stream, Body2} -&gt;
<font color=red>     0..|                      send_stream_body(PassedState#wm_reqstate.socket, Body2);</font>
        |                  {writer, Body2} -&gt;
<font color=red>     0..|                      send_writer_body(PassedState#wm_reqstate.socket, Body2);</font>
        |                  _ -&gt;
<font color=red>     0..|                      send(PassedState#wm_reqstate.socket, Body),</font>
<font color=red>     0..|                      Length</font>
        |              end
        |      end,
<font color=red>     0..|      InitLogData = PassedState#wm_reqstate.log_data,</font>
<font color=red>     0..|      FinalLogData = InitLogData#wm_log_data{response_code=Code,</font>
        |                                             response_length=FinalLength},
<font color=red>     0..|      {ok, PassedState#wm_reqstate{reqdata=wrq:set_response_code(Code, RD),</font>
        |                       log_data=FinalLogData}}.
        |  
        |  %% @doc  Infer body length from transfer-encoding and content-length headers.
        |  body_length() -&gt;
<font color=red>     0..|      case get_header_value("transfer-encoding") of</font>
        |          {undefined, _} -&gt;
<font color=red>     0..|              case get_header_value("content-length") of</font>
<font color=red>     0..|                  {undefined, _} -&gt; undefined;</font>
<font color=red>     0..|                  {Length, _} -&gt; list_to_integer(Length)</font>
        |              end;
<font color=red>     0..|          {"chunked", _} -&gt; chunked;</font>
<font color=red>     0..|          Unknown -&gt; {unknown_transfer_encoding, Unknown}</font>
        |      end.
        |  
        |  %% @doc Receive the body of the HTTP request (defined by Content-Length).
        |  %%      Will only receive up to the default max-body length
        |  do_recv_body(PassedState=#wm_reqstate{reqdata=RD}) -&gt;
<font color=red>     0..|      MRH = RD#wm_reqdata.max_recv_hunk,</font>
<font color=red>     0..|      MRB = RD#wm_reqdata.max_recv_body,</font>
<font color=red>     0..|      read_whole_stream(recv_stream_body(PassedState, MRH), [], MRB, 0).</font>
        |  
        |  read_whole_stream({Hunk,_}, _, MaxRecvBody, SizeAcc)
        |    when SizeAcc + byte_size(Hunk) &gt; MaxRecvBody -&gt; 
<font color=red>     0..|      {error, req_body_too_large};</font>
        |  read_whole_stream({Hunk,Next}, Acc0, MaxRecvBody, SizeAcc) -&gt;
<font color=red>     0..|      HunkSize = byte_size(Hunk),</font>
<font color=red>     0..|      if SizeAcc + HunkSize &gt; MaxRecvBody -&gt; </font>
<font color=red>     0..|              {error, req_body_too_large};</font>
        |         true -&gt;
<font color=red>     0..|              Acc = [Hunk|Acc0],</font>
<font color=red>     0..|              case Next of</font>
<font color=red>     0..|                  done -&gt; iolist_to_binary(lists:reverse(Acc));</font>
<font color=red>     0..|                  _ -&gt; read_whole_stream(Next(), Acc,</font>
        |                                         MaxRecvBody, SizeAcc + HunkSize)
        |              end
        |      end.
        |  
        |  recv_stream_body(PassedState=#wm_reqstate{reqdata=RD}, MaxHunkSize) -&gt;
<font color=red>     0..|      put(mochiweb_request_recv, true),</font>
<font color=red>     0..|      case get_header_value("expect") of</font>
        |          {"100-continue", _} -&gt;
<font color=red>     0..|              send(PassedState#wm_reqstate.socket, </font>
        |                   [make_version(wrq:version(RD)),
        |                    make_code(100), &lt;&lt;"\r\n\r\n"&gt;&gt;]);
        |          _Else -&gt;
<font color=red>     0..|              ok</font>
        |      end,
<font color=red>     0..|      case body_length() of</font>
<font color=red>     0..|          {unknown_transfer_encoding, X} -&gt; exit({unknown_transfer_encoding, X});</font>
<font color=red>     0..|          undefined -&gt; {&lt;&lt;&gt;&gt;, done};</font>
<font color=red>     0..|          0 -&gt; {&lt;&lt;&gt;&gt;, done};</font>
<font color=red>     0..|          chunked -&gt; recv_chunked_body(PassedState#wm_reqstate.socket,</font>
        |                                       MaxHunkSize);
<font color=red>     0..|          Length -&gt; recv_unchunked_body(PassedState#wm_reqstate.socket,</font>
        |                                        MaxHunkSize, Length)
        |      end.
        |  
        |  recv_unchunked_body(Socket, MaxHunk, DataLeft) -&gt;
<font color=red>     0..|      case MaxHunk &gt;= DataLeft of</font>
        |          true -&gt;
<font color=red>     0..|              {ok,Data1} = mochiweb_socket:recv(Socket,DataLeft,?IDLE_TIMEOUT),</font>
<font color=red>     0..|              {Data1, done};</font>
        |          false -&gt;
<font color=red>     0..|              {ok,Data2} = mochiweb_socket:recv(Socket,MaxHunk,?IDLE_TIMEOUT),</font>
<font color=red>     0..|              {Data2,</font>
<font color=red>     0..|               fun() -&gt; recv_unchunked_body(</font>
        |                          Socket, MaxHunk, DataLeft-MaxHunk)
        |               end}
        |      end.
        |      
        |  recv_chunked_body(Socket, MaxHunk) -&gt;
<font color=red>     0..|      case read_chunk_length(Socket) of</font>
<font color=red>     0..|          0 -&gt; {&lt;&lt;&gt;&gt;, done};</font>
<font color=red>     0..|          ChunkLength -&gt; recv_chunked_body(Socket,MaxHunk,ChunkLength)</font>
        |      end.
        |  recv_chunked_body(Socket, MaxHunk, LeftInChunk) -&gt;
<font color=red>     0..|      case MaxHunk &gt;= LeftInChunk of</font>
        |          true -&gt;
<font color=red>     0..|              {ok,Data1} = mochiweb_socket:recv(Socket,LeftInChunk,?IDLE_TIMEOUT),</font>
<font color=red>     0..|              {Data1,</font>
<font color=red>     0..|               fun() -&gt; recv_chunked_body(Socket, MaxHunk)</font>
        |               end};
        |          false -&gt;
<font color=red>     0..|              {ok,Data2} = mochiweb_socket:recv(Socket,MaxHunk,?IDLE_TIMEOUT),</font>
<font color=red>     0..|              {Data2,</font>
<font color=red>     0..|               fun() -&gt; recv_chunked_body(Socket, MaxHunk, LeftInChunk-MaxHunk)</font>
        |               end}
        |      end.
        |  
        |  read_chunk_length(Socket) -&gt;
<font color=red>     0..|      mochiweb_socket:setopts(Socket, [{packet, line}]),</font>
<font color=red>     0..|      case mochiweb_socket:recv(Socket, 0, ?IDLE_TIMEOUT) of</font>
        |          {ok, Header} -&gt;
<font color=red>     0..|              mochiweb_socket:setopts(Socket, [{packet, raw}]),</font>
<font color=red>     0..|              Splitter = fun (C) -&gt;</font>
<font color=red>     0..|                                 C =/= $\r andalso C =/= $\n andalso C =/= $</font>
        |                         end,
<font color=red>     0..|              {Hex, _Rest} = lists:splitwith(Splitter, binary_to_list(Header)),</font>
<font color=red>     0..|              case Hex of</font>
<font color=red>     0..|                  [] -&gt; 0;</font>
<font color=red>     0..|                  _ -&gt; erlang:list_to_integer(Hex, 16)</font>
        |              end;
        |          _ -&gt;
<font color=red>     0..|              exit(normal)</font>
        |      end.
        |  
        |  get_range() -&gt;
<font color=red>     0..|      case get_header_value("range") of</font>
        |          {undefined, _} -&gt;
<font color=red>     0..|              {undefined, ReqState#wm_reqstate{range=undefined}};</font>
        |          {RawRange, _} -&gt;
<font color=red>     0..|              Range = parse_range_request(RawRange),</font>
<font color=red>     0..|              {Range, ReqState#wm_reqstate{range=Range}}</font>
        |      end.
        |  
        |  range_parts(_RD=#wm_reqdata{resp_body={file, IoDevice}}, Ranges) -&gt;
<font color=red>     0..|      Size = mochiweb_io:iodevice_size(IoDevice),</font>
<font color=red>     0..|      F = fun (Spec, Acc) -&gt;</font>
<font color=red>     0..|                  case range_skip_length(Spec, Size) of</font>
        |                      invalid_range -&gt;
<font color=red>     0..|                          Acc;</font>
        |                      V -&gt;
<font color=red>     0..|                          [V | Acc]</font>
        |                  end
        |          end,
<font color=red>     0..|      LocNums = lists:foldr(F, [], Ranges),</font>
<font color=red>     0..|      {ok, Data} = file:pread(IoDevice, LocNums),</font>
<font color=red>     0..|      Bodies = lists:zipwith(fun ({Skip, Length}, PartialBody) -&gt;</font>
<font color=red>     0..|                                     {Skip, Skip + Length - 1, PartialBody}</font>
        |                             end,
        |                             LocNums, Data),
<font color=red>     0..|      {Bodies, Size};</font>
        |  
        |  range_parts(RD=#wm_reqdata{resp_body={stream, {Hunk,Next}}}, Ranges) -&gt;
        |      % for now, streamed bodies are read in full for range requests
<font color=red>     0..|      MRB = RD#wm_reqdata.max_recv_body,</font>
<font color=red>     0..|      range_parts(read_whole_stream({Hunk,Next}, [], MRB, 0), Ranges);</font>
        |  
        |  range_parts(_RD=#wm_reqdata{resp_body={stream, Size, StreamFun}}, Ranges) -&gt;
<font color=red>     0..|      SkipLengths = [ range_skip_length(R, Size) || R &lt;- Ranges],</font>
<font color=red>     0..|      {[ {Skip, Skip+Length-1, StreamFun} || {Skip, Length} &lt;- SkipLengths ],</font>
        |       Size};
        |  
        |  range_parts(Body0, Ranges) when is_binary(Body0); is_list(Body0) -&gt;
<font color=red>     0..|      Body = iolist_to_binary(Body0),</font>
<font color=red>     0..|      Size = size(Body),</font>
<font color=red>     0..|      F = fun(Spec, Acc) -&gt;</font>
<font color=red>     0..|                  case range_skip_length(Spec, Size) of</font>
        |                      invalid_range -&gt;
<font color=red>     0..|                          Acc;</font>
        |                      {Skip, Length} -&gt;
        |                          &lt;&lt;_:Skip/binary,
        |                           PartialBody:Length/binary,
<font color=red>     0..|                           _/binary&gt;&gt; = Body,</font>
<font color=red>     0..|                          [{Skip, Skip + Length - 1, PartialBody} | Acc]</font>
        |                  end
        |          end,
<font color=red>     0..|      {lists:foldr(F, [], Ranges), Size}.</font>
        |  
        |  range_skip_length(Spec, Size) -&gt;
<font color=red>     0..|      case Spec of</font>
        |          {none, R} when R =&lt; Size, R &gt;= 0 -&gt;
<font color=red>     0..|              {Size - R, R};</font>
        |          {none, _OutOfRange} -&gt;
<font color=red>     0..|              {0, Size};</font>
        |          {R, none} when R &gt;= 0, R &lt; Size -&gt;
<font color=red>     0..|              {R, Size - R};</font>
        |          {_OutOfRange, none} -&gt;
<font color=red>     0..|              invalid_range;</font>
        |          {Start, End} when 0 =&lt; Start, Start =&lt; End, End &lt; Size -&gt;
<font color=red>     0..|              {Start, End - Start + 1};</font>
        |          {_OutOfRange, _End} -&gt;
<font color=red>     0..|              invalid_range</font>
        |      end.
        |  
        |  parse_range_request(RawRange) when is_list(RawRange) -&gt;
<font color=red>     0..|      try</font>
<font color=red>     0..|          "bytes=" ++ RangeString = RawRange,</font>
<font color=red>     0..|          Ranges = string:tokens(RangeString, ","),</font>
<font color=red>     0..|          lists:map(fun ("-" ++ V)  -&gt;</font>
<font color=red>     0..|                            {none, list_to_integer(V)};</font>
        |                        (R) -&gt;
<font color=red>     0..|                            case string:tokens(R, "-") of</font>
        |                                [S1, S2] -&gt;
<font color=red>     0..|                                    {list_to_integer(S1), list_to_integer(S2)};</font>
        |                                [S] -&gt;
<font color=red>     0..|                                    {list_to_integer(S), none}</font>
        |                            end
        |                    end,
        |                    Ranges)
        |      catch
        |          _:_ -&gt;
<font color=red>     0..|              fail</font>
        |      end.
        |  
        |  parts_to_body([{Start, End, Body0}], Size) -&gt;
        |      %% return body for a range reponse with a single body
<font color=red>     0..|      ContentType = </font>
        |          case get_outheader_value("content-type") of
        |              {undefined, _} -&gt;
<font color=red>     0..|                  "text/html";</font>
        |              {CT, _} -&gt;
<font color=red>     0..|                  CT</font>
        |          end,
<font color=red>     0..|      HeaderList = [{"Content-Type", ContentType},</font>
        |                    {"Content-Range",
        |                     ["bytes ",
        |                      mochiweb_util:make_io(Start), "-", 
        |                      mochiweb_util:make_io(End),
        |                      "/", mochiweb_util:make_io(Size)]}],
<font color=red>     0..|      Body = if is_function(Body0) -&gt;</font>
<font color=red>     0..|                     {stream, Body0(Start, End)};</font>
        |                true -&gt;
<font color=red>     0..|                     Body0</font>
        |             end,
<font color=red>     0..|      {HeaderList, Body};</font>
        |  parts_to_body(BodyList, Size) when is_list(BodyList) -&gt;
        |      %% return
        |      %% header Content-Type: multipart/byteranges; boundary=441934886133bdee4
        |      %% and multipart body
<font color=red>     0..|      ContentType = </font>
        |          case get_outheader_value("content-type") of
        |              {undefined, _} -&gt;
<font color=red>     0..|                  "text/html";</font>
        |              {CT, _} -&gt;
<font color=red>     0..|                  CT</font>
        |          end,
<font color=red>     0..|      Boundary = mochihex:to_hex(crypto:rand_bytes(8)),</font>
<font color=red>     0..|      HeaderList = [{"Content-Type",</font>
        |                     ["multipart/byteranges; ",
        |                      "boundary=", Boundary]}],
<font color=red>     0..|      MultiPartBody = case hd(BodyList) of</font>
        |                          {_, _, Fun} when is_function(Fun) -&gt;
<font color=red>     0..|                              stream_multipart_body(BodyList, ContentType,</font>
        |                                                    Boundary, Size);
        |                          _ -&gt;
<font color=red>     0..|                              multipart_body(BodyList, ContentType,</font>
        |                                             Boundary, Size)
        |                      end,
<font color=red>     0..|      {HeaderList, MultiPartBody}.</font>
        |  
        |  multipart_body([], _ContentType, Boundary, _Size) -&gt;
<font color=red>     0..|      end_boundary(Boundary);</font>
        |  multipart_body([{Start, End, Body} | BodyList], ContentType, Boundary, Size) -&gt;
<font color=red>     0..|      [part_preamble(Boundary, ContentType, Start, End, Size),</font>
        |       Body, &lt;&lt;"\r\n"&gt;&gt;
        |       | multipart_body(BodyList, ContentType, Boundary, Size)].
        |  
<font color=red>     0..|  boundary(B)     -&gt; [&lt;&lt;"--"&gt;&gt;, B, &lt;&lt;"\r\n"&gt;&gt;].</font>
<font color=red>     0..|  end_boundary(B) -&gt; [&lt;&lt;"--"&gt;&gt;, B, &lt;&lt;"--\r\n"&gt;&gt;].</font>
        |  
        |  part_preamble(Boundary, CType, Start, End, Size) -&gt;
<font color=red>     0..|      [boundary(Boundary),</font>
        |       &lt;&lt;"Content-Type: "&gt;&gt;, CType, &lt;&lt;"\r\n"&gt;&gt;,
        |       &lt;&lt;"Content-Range: bytes "&gt;&gt;,
        |       mochiweb_util:make_io(Start), &lt;&lt;"-"&gt;&gt;, mochiweb_util:make_io(End),
        |       &lt;&lt;"/"&gt;&gt;, mochiweb_util:make_io(Size),
        |       &lt;&lt;"\r\n\r\n"&gt;&gt;].
        |  
        |  stream_multipart_body(BodyList, ContentType, Boundary, Size) -&gt;
<font color=red>     0..|      Helper = stream_multipart_body_helper(</font>
        |                 BodyList, ContentType, Boundary, Size),
        |      %% executing Helper() here is an optimization;
        |      %% it's just as valid to say {&lt;&lt;&gt;&gt;, Helper}
<font color=red>     0..|      {stream, Helper()}.</font>
        |  
        |  stream_multipart_body_helper([], _CType, Boundary, _Size) -&gt;
<font color=red>     0..|      fun() -&gt; {end_boundary(Boundary), done} end;</font>
        |  stream_multipart_body_helper([{Start, End, Fun}|Rest],
        |                               CType, Boundary, Size) -&gt;
<font color=red>     0..|      fun() -&gt;</font>
<font color=red>     0..|              {part_preamble(Boundary, CType, Start, End, Size),</font>
        |               stream_multipart_part_helper(
<font color=red>     0..|                 fun() -&gt; Fun(Start, End) end,</font>
        |                 Rest, CType, Boundary, Size)}
        |      end.
        |  
        |  stream_multipart_part_helper(Fun, Rest, CType, Boundary, Size) -&gt;
<font color=red>     0..|      fun() -&gt;</font>
<font color=red>     0..|              case Fun() of</font>
        |                  {Data, done} -&gt;
        |                      %% when this part is done, start the next part
<font color=red>     0..|                      {[Data, &lt;&lt;"\r\n"&gt;&gt;],</font>
        |                       stream_multipart_body_helper(
        |                         Rest, CType, Boundary, Size)};
        |                  {Data, Next} -&gt;
        |                      %% this subpart has more data coming
<font color=red>     0..|                      {Data, stream_multipart_part_helper(</font>
        |                               Next, Rest, CType, Boundary, Size)}
        |              end
        |      end.
        |  
        |  make_code(X) when is_integer(X) -&gt;
<font color=red>     0..|      [integer_to_list(X), [" " | httpd_util:reason_phrase(X)]];</font>
        |  make_code(Io) when is_list(Io); is_binary(Io) -&gt;
<font color=red>     0..|      Io.</font>
        |  
        |  make_version({1, 0}) -&gt;
<font color=red>     0..|      &lt;&lt;"HTTP/1.0 "&gt;&gt;;</font>
        |  make_version(_) -&gt;
<font color=red>     0..|      &lt;&lt;"HTTP/1.1 "&gt;&gt;.</font>
        |  
        |  make_headers(Code, Length, RD) -&gt;
<font color=red>     0..|      Hdrs0 = case Code of</font>
        |          304 -&gt;
<font color=red>     0..|              mochiweb_headers:make(wrq:resp_headers(RD));</font>
        |          _ -&gt; 
<font color=red>     0..|              case Length of</font>
        |                  chunked -&gt;
<font color=red>     0..|                      mochiweb_headers:enter(</font>
        |                        "Transfer-Encoding","chunked",
        |                        mochiweb_headers:make(wrq:resp_headers(RD)));
        |                  _ -&gt;
<font color=red>     0..|                      mochiweb_headers:enter(</font>
        |                        "Content-Length",integer_to_list(Length),
        |                        mochiweb_headers:make(wrq:resp_headers(RD)))
        |              end
        |      end,
<font color=red>     0..|      ServerHeader = "MochiWeb/1.1 WebMachine/" ++ ?WMVSN ++ " (" ++ ?QUIP ++ ")",</font>
<font color=red>     0..|      WithSrv = mochiweb_headers:enter("Server", ServerHeader, Hdrs0),</font>
<font color=red>     0..|      Hdrs = case mochiweb_headers:get_value("date", WithSrv) of</font>
        |          undefined -&gt;
<font color=red>     0..|              mochiweb_headers:enter("Date", httpd_util:rfc1123_date(), WithSrv);</font>
        |          _ -&gt;
<font color=red>     0..|              WithSrv</font>
        |      end,
<font color=red>     0..|      F = fun({K, V}, Acc) -&gt;</font>
<font color=red>     0..|                  [mochiweb_util:make_io(K), &lt;&lt;": "&gt;&gt;, V, &lt;&lt;"\r\n"&gt;&gt; | Acc]</font>
        |          end,
<font color=red>     0..|      lists:foldl(F, [&lt;&lt;"\r\n"&gt;&gt;], mochiweb_headers:to_list(Hdrs)).</font>
        |  
<font color=red>     0..|  get_reqdata() -&gt; call(get_reqdata).</font>
        |  
<font color=red>     0..|  set_reqdata(RD) -&gt; call({set_reqdata, RD}).</font>
        |  
<font color=red>     0..|  socket() -&gt; call(socket).</font>
        |  
<font color=red>     0..|  method() -&gt; call(method).</font>
        |  
<font color=red>     0..|  version() -&gt; call(version).</font>
        |  
<font color=red>     0..|  disp_path() -&gt; call(disp_path).</font>
        |  
<font color=red>     0..|  path() -&gt; call(path).</font>
        |  
<font color=red>     0..|  raw_path() -&gt; call(raw_path).</font>
        |  
<font color=red>     0..|  req_headers() -&gt; call(req_headers).</font>
<font color=red>     0..|  headers() -&gt; req_headers().</font>
        |  
<font color=red>     0..|  req_body(MaxRevBody) -&gt; call({req_body,MaxRevBody}).</font>
<font color=red>     0..|  stream_req_body(MaxHunk) -&gt; call({stream_req_body, MaxHunk}).</font>
        |  
<font color=red>     0..|  resp_headers() -&gt; call(resp_headers).</font>
<font color=red>     0..|  out_headers() -&gt; resp_headers().</font>
        |  
<font color=red>     0..|  get_resp_header(HeaderName) -&gt; call({get_resp_header, HeaderName}).</font>
<font color=red>     0..|  get_out_header(HeaderName) -&gt; get_resp_header(HeaderName).</font>
        |  
        |  has_resp_header(HeaderName) -&gt;
<font color=red>     0..|      case get_out_header(HeaderName) of</font>
<font color=red>     0..|          {undefined, _} -&gt; false;</font>
<font color=red>     0..|          {_, _}         -&gt; true</font>
        |      end.
<font color=red>     0..|  has_out_header(HeaderName) -&gt; has_resp_header(HeaderName).</font>
        |  
<font color=red>     0..|  has_resp_body() -&gt; call(has_resp_body).</font>
<font color=red>     0..|  has_response_body() -&gt; has_resp_body().</font>
        |  
<font color=red>     0..|  response_code() -&gt; call(response_code).</font>
<font color=red>     0..|  set_response_code(Code) -&gt; call({set_response_code, Code}).</font>
        |  
<font color=red>     0..|  peer() -&gt; call(peer).</font>
        |  
<font color=red>     0..|  range() -&gt; call(range).</font>
        |  
<font color=red>     0..|  req_cookie() -&gt; call(req_cookie).</font>
<font color=red>     0..|  parse_cookie() -&gt; req_cookie().</font>
        |  get_cookie_value(Key) -&gt;
<font color=red>     0..|      {ReqCookie, NewReqState} = req_cookie(),</font>
<font color=red>     0..|      {proplists:get_value(Key, ReqCookie), NewReqState}.</font>
        |  
<font color=red>     0..|  req_qs() -&gt; call(req_qs).</font>
<font color=red>     0..|  parse_qs() -&gt; req_qs().</font>
        |  get_qs_value(Key) -&gt;
<font color=red>     0..|      {ReqQS, NewReqState} = req_qs(),</font>
<font color=red>     0..|      {proplists:get_value(Key, ReqQS), NewReqState}.</font>
        |  get_qs_value(Key, Default) -&gt;
<font color=red>     0..|      {ReqQS, NewReqState} = req_qs(),</font>
<font color=red>     0..|      {proplists:get_value(Key, ReqQS, Default), NewReqState}.</font>
        |  
<font color=red>     0..|  set_resp_body(Body) -&gt; call({set_resp_body, Body}).</font>
<font color=red>     0..|  resp_body() -&gt; call(resp_body).</font>
<font color=red>     0..|  response_body() -&gt; resp_body().</font>
        |  
<font color=red>     0..|  get_req_header(K) -&gt; call({get_req_header, K}).</font>
        |  
<font color=red>     0..|  set_resp_header(K, V) -&gt; call({set_resp_header, K, V}).</font>
<font color=red>     0..|  add_response_header(K, V) -&gt; set_resp_header(K, V).</font>
        |  
<font color=red>     0..|  set_resp_headers(Hdrs) -&gt; call({set_resp_headers, Hdrs}).</font>
<font color=red>     0..|  add_response_headers(Hdrs) -&gt; set_resp_headers(Hdrs).</font>
        |  
<font color=red>     0..|  remove_resp_header(K) -&gt; call({remove_resp_header, K}).</font>
<font color=red>     0..|  remove_response_header(K) -&gt; remove_resp_header(K).</font>
        |  
<font color=red>     0..|  merge_resp_headers(Hdrs) -&gt; call({merge_resp_headers, Hdrs}).</font>
<font color=red>     0..|  merge_response_headers(Hdrs) -&gt; merge_resp_headers(Hdrs).</font>
        |  
<font color=red>     0..|  append_to_response_body(Data) -&gt; call({append_to_response_body, Data}).</font>
        |  
<font color=red>     0..|  do_redirect() -&gt; call(do_redirect).</font>
        |  
<font color=red>     0..|  resp_redirect() -&gt; call(resp_redirect).</font>
        |  
<font color=red>     0..|  get_metadata(Key) -&gt; call({get_metadata, Key}).</font>
        |  
<font color=red>     0..|  set_metadata(Key, Value) -&gt; call({set_metadata, Key, Value}).</font>
        |  
<font color=red>     0..|  get_path_info() -&gt; call(get_path_info).</font>
        |  
<font color=red>     0..|  get_path_info(Key) -&gt; call({get_path_info, Key}).</font>
        |  
<font color=red>     0..|  path_tokens() -&gt; call(path_tokens).</font>
<font color=red>     0..|  get_path_tokens() -&gt; path_tokens().</font>
        |  
<font color=red>     0..|  app_root() -&gt; call(app_root).</font>
<font color=red>     0..|  get_app_root() -&gt; app_root().</font>
        |  
        |  load_dispatch_data(Bindings, HostTokens, Port, PathTokens,
        |                     AppRoot, DispPath) -&gt;
<font color=red>     0..|      call({load_dispatch_data, Bindings, HostTokens, Port,</font>
        |            PathTokens, AppRoot, DispPath}).
        |  
<font color=red>     0..|  log_data() -&gt; call(log_data).</font>
</pre>
</body>
</html>
