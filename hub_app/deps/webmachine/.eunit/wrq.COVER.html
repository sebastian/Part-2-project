<html>
<head><title>.eunit/wrq.COVER.html</title></head><body bgcolor=white text=black>
<pre>
File generated from /Users/seb/Documents/part2project/app/deps/webmachine/.eunit/wrq.erl by COVER 2010-10-28 at 14:19:55

****************************************************************************

        |  %% @author Justin Sheehy &lt;justin@basho.com&gt;
        |  %% @copyright 2007-2009 Basho Technologies
        |  %%
        |  %%    Licensed under the Apache License, Version 2.0 (the "License");
        |  %%    you may not use this file except in compliance with the License.
        |  %%    You may obtain a copy of the License at
        |  %%
        |  %%        http://www.apache.org/licenses/LICENSE-2.0
        |  %%
        |  %%    Unless required by applicable law or agreed to in writing, software
        |  %%    distributed under the License is distributed on an "AS IS" BASIS,
        |  %%    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        |  %%    See the License for the specific language governing permissions and
        |  %%    limitations under the License.
        |  
        |  -module(wrq).
        |  -author('Justin Sheehy &lt;justin@basho.com&gt;').
        |  
        |  -export([create/4,load_dispatch_data/7]).
        |  -export([method/1,version/1,peer/1,disp_path/1,path/1,raw_path/1,path_info/1,
        |           response_code/1,req_cookie/1,req_qs/1,req_headers/1,req_body/1,
        |           stream_req_body/2,resp_redirect/1,resp_headers/1,resp_body/1,
        |           app_root/1,path_tokens/1, host_tokens/1, port/1]).
        |  -export([path_info/2,get_req_header/2,do_redirect/2,fresh_resp_headers/2,
        |           get_resp_header/2,set_resp_header/3,set_resp_headers/2,
        |           set_disp_path/2,set_req_body/2,set_resp_body/2,set_response_code/2,
        |           merge_resp_headers/2,remove_resp_header/2,
        |           append_to_resp_body/2,append_to_response_body/2,
        |           max_recv_body/1,set_max_recv_body/2,
        |           get_cookie_value/2,get_qs_value/2,get_qs_value/3,set_peer/2,
        |           add_note/3, get_notes/1]).
        |  
        |  % @type reqdata(). The opaque data type used for req/resp data structures.
        |  -include_lib("include/wm_reqdata.hrl").
        |  -include_lib("include/wm_reqstate.hrl").
        |  -include_lib("eunit/include/eunit.hrl").
        |  
        |  
        |  create(Method,Version,RawPath,Headers) -&gt;
     2..|      create(#wm_reqdata{method=Method,version=Version,
        |                         raw_path=RawPath,req_headers=Headers,
        |        wm_state=defined_on_call,
        |        path="defined_in_create",
        |        req_cookie=defined_in_create,
        |        req_qs=defined_in_create,
        |        peer="defined_in_wm_req_srv_init",
        |        req_body=not_fetched_yet,
        |        max_recv_body=(1024*(1024*1024)),
        |        % Stolen from R13B03 inet_drv.c's TCP_MAX_PACKET_SIZE definition
        |        max_recv_hunk=(64*(1024*1024)),
        |        app_root="defined_in_load_dispatch_data",
        |        path_info=dict:new(),
        |        path_tokens=defined_in_load_dispatch_data,
        |        disp_path=defined_in_load_dispatch_data,
        |        resp_redirect=false, resp_headers=mochiweb_headers:empty(),
        |        resp_body = &lt;&lt;&gt;&gt;, response_code=500,
        |        notes=[]}).
        |  create(RD = #wm_reqdata{raw_path=RawPath}) -&gt;
     2..|      {Path, _, _} = mochiweb_util:urlsplit_path(RawPath),
     2..|      Cookie = case get_req_header("cookie", RD) of
<font color=red>     0..|                   undefined -&gt; [];</font>
     2..|                   Value -&gt; mochiweb_cookies:parse_cookie(Value)
        |               end,
     2..|      {_, QueryString, _} = mochiweb_util:urlsplit_path(RawPath),
     2..|      ReqQS = mochiweb_util:parse_qs(QueryString),
     2..|      RD#wm_reqdata{path=Path,req_cookie=Cookie,req_qs=ReqQS}.
        |  load_dispatch_data(PathInfo, HostTokens, Port, PathTokens, AppRoot,
        |                     DispPath, RD) -&gt;
     1..|      RD#wm_reqdata{path_info=PathInfo,host_tokens=HostTokens,
        |                    port=Port,path_tokens=PathTokens,
        |                    app_root=AppRoot,disp_path=DispPath}.
        |  
     1..|  method(_RD = #wm_reqdata{method=Method}) -&gt; Method.
        |  
        |  version(_RD = #wm_reqdata{version=Version})
        |    when is_tuple(Version), size(Version) == 2,
     1..|       is_integer(element(1,Version)), is_integer(element(2,Version)) -&gt; Version.
        |  
     1..|  peer(_RD = #wm_reqdata{peer=Peer}) when is_list(Peer) -&gt; Peer.
        |  
     1..|  app_root(_RD = #wm_reqdata{app_root=AR}) when is_list(AR) -&gt; AR.
        |  
        |  % all three paths below are strings
<font color=red>     0..|  disp_path(_RD = #wm_reqdata{disp_path=DP}) when is_list(DP) -&gt; DP.</font>
        |  
     1..|  path(_RD = #wm_reqdata{path=Path}) when is_list(Path) -&gt; Path.
        |  
     1..|  raw_path(_RD = #wm_reqdata{raw_path=RawPath}) when is_list(RawPath) -&gt; RawPath.
        |  
<font color=red>     0..|  path_info(_RD = #wm_reqdata{path_info=PathInfo}) -&gt; PathInfo. % dict</font>
        |  
<font color=red>     0..|  path_tokens(_RD = #wm_reqdata{path_tokens=PathT}) -&gt; PathT. % list of strings</font>
        |  
<font color=red>     0..|  host_tokens(_RD = #wm_reqdata{host_tokens=HostT}) -&gt; HostT. % list of strings</font>
        |  
     1..|  port(_RD = #wm_reqdata{port=Port}) -&gt; Port. % integer
        |  
<font color=red>     0..|  response_code(_RD = #wm_reqdata{response_code=C}) when is_integer(C) -&gt; C.</font>
        |  
     2..|  req_cookie(_RD = #wm_reqdata{req_cookie=C}) when is_list(C) -&gt; C. % string
        |  
        |  %% @spec req_qs(reqdata()) -&gt; [{Key, Value}]
     4..|  req_qs(_RD = #wm_reqdata{req_qs=QS}) when is_list(QS) -&gt; QS.
        |  
     2..|  req_headers(_RD = #wm_reqdata{req_headers=ReqH}) -&gt; ReqH. % mochiheaders
        |  
        |  req_body(_RD = #wm_reqdata{wm_state=ReqState0,max_recv_body=MRB}) -&gt;
<font color=red>     0..|      Req = webmachine_request:new(ReqState0),</font>
<font color=red>     0..|      {ReqResp, ReqState} = Req:req_body(MRB),</font>
<font color=red>     0..|      put(tmp_reqstate, ReqState),</font>
<font color=red>     0..|      maybe_conflict_body(ReqResp).</font>
        |  
        |  stream_req_body(_RD = #wm_reqdata{wm_state=ReqState0}, MaxHunk) -&gt;
<font color=red>     0..|      Req = webmachine_request:new(ReqState0),</font>
<font color=red>     0..|      {ReqResp, ReqState} = Req:stream_req_body(MaxHunk),</font>
<font color=red>     0..|      put(tmp_reqstate, ReqState),</font>
<font color=red>     0..|      maybe_conflict_body(ReqResp).</font>
        |  
<font color=red>     0..|  max_recv_body(_RD = #wm_reqdata{max_recv_body=X}) when is_integer(X) -&gt; X.</font>
        |  
<font color=red>     0..|  set_max_recv_body(X, RD) when is_integer(X) -&gt; RD#wm_reqdata{max_recv_body=X}.</font>
        |  
        |  maybe_conflict_body(BodyResponse) -&gt;
<font color=red>     0..|      case BodyResponse of</font>
        |          stream_conflict -&gt;
<font color=red>     0..|              exit("wrq:req_body and wrq:stream_req_body conflict");</font>
        |          {error, req_body_too_large} -&gt;
<font color=red>     0..|              exit("request body too large");</font>
        |          _ -&gt;
<font color=red>     0..|              BodyResponse</font>
        |      end.
        |  
<font color=red>     0..|  resp_redirect(_RD = #wm_reqdata{resp_redirect=true}) -&gt; true;</font>
<font color=red>     0..|  resp_redirect(_RD = #wm_reqdata{resp_redirect=false}) -&gt; false.</font>
        |  
<font color=red>     0..|  resp_headers(_RD = #wm_reqdata{resp_headers=RespH}) -&gt; RespH. % mochiheaders</font>
        |  
<font color=red>     0..|  resp_body(_RD = #wm_reqdata{resp_body=undefined}) -&gt; undefined;</font>
<font color=red>     0..|  resp_body(_RD = #wm_reqdata{resp_body={stream,X}}) -&gt; {stream,X};</font>
<font color=red>     0..|  resp_body(_RD = #wm_reqdata{resp_body={stream,X,Y}}) -&gt; {stream,X,Y};</font>
<font color=red>     0..|  resp_body(_RD = #wm_reqdata{resp_body={writer,X}}) -&gt; {writer,X};</font>
<font color=red>     0..|  resp_body(_RD = #wm_reqdata{resp_body=RespB}) when is_binary(RespB) -&gt; RespB;</font>
<font color=red>     0..|  resp_body(_RD = #wm_reqdata{resp_body=RespB}) -&gt; iolist_to_binary(RespB).</font>
        |  
        |  %% --
        |  
        |  path_info(Key, RD) when is_atom(Key) -&gt;
<font color=red>     0..|      case dict:find(Key, path_info(RD)) of</font>
        |          {ok, Value} when is_list(Value); is_integer(Value) -&gt;
<font color=red>     0..|              Value; % string (for host or path match)</font>
        |                     % or integer (for port match)
<font color=red>     0..|          error -&gt; undefined</font>
        |      end.
        |  
        |  get_req_header(HdrName, RD) -&gt; % string-&gt;string
     2..|      mochiweb_headers:get_value(HdrName, req_headers(RD)).
        |  
<font color=red>     0..|  do_redirect(true, RD) -&gt;  RD#wm_reqdata{resp_redirect=true};</font>
<font color=red>     0..|  do_redirect(false, RD) -&gt; RD#wm_reqdata{resp_redirect=false}.</font>
        |  
     2..|  set_peer(P, RD) when is_list(P) -&gt; RD#wm_reqdata{peer=P}. % string
        |  
<font color=red>     0..|  set_disp_path(P, RD) when is_list(P) -&gt; RD#wm_reqdata{disp_path=P}. % string</font>
        |  
<font color=red>     0..|  set_req_body(Body, RD) -&gt; RD#wm_reqdata{req_body=Body}.</font>
        |  
<font color=red>     0..|  set_resp_body(Body, RD) -&gt; RD#wm_reqdata{resp_body=Body}.</font>
        |  
        |  set_response_code(Code, RD) when is_integer(Code) -&gt;
<font color=red>     0..|      RD#wm_reqdata{response_code=Code}.</font>
        |  
        |  get_resp_header(HdrName, _RD=#wm_reqdata{resp_headers=RespH}) -&gt;
<font color=red>     0..|      mochiweb_headers:get_value(HdrName, RespH).</font>
        |  set_resp_header(K, V, RD=#wm_reqdata{resp_headers=RespH})
        |    when is_list(K),is_list(V) -&gt;
<font color=red>     0..|      RD#wm_reqdata{resp_headers=mochiweb_headers:enter(K, V, RespH)}.</font>
        |  set_resp_headers(Hdrs, RD=#wm_reqdata{resp_headers=RespH}) -&gt;
<font color=red>     0..|      F = fun({K, V}, Acc) -&gt; mochiweb_headers:enter(K, V, Acc) end,</font>
<font color=red>     0..|      RD#wm_reqdata{resp_headers=lists:foldl(F, RespH, Hdrs)}.</font>
        |  fresh_resp_headers(Hdrs, RD) -&gt;
<font color=red>     0..|      F = fun({K, V}, Acc) -&gt; mochiweb_headers:enter(K, V, Acc) end,</font>
<font color=red>     0..|      RD#wm_reqdata{resp_headers=lists:foldl(F, mochiweb_headers:empty(), Hdrs)}.</font>
        |  remove_resp_header(K, RD=#wm_reqdata{resp_headers=RespH}) when is_list(K) -&gt;
<font color=red>     0..|      RD#wm_reqdata{resp_headers=mochiweb_headers:from_list(</font>
        |                                   proplists:delete(K,
        |                                       mochiweb_headers:to_list(RespH)))}.
        |  
        |  merge_resp_headers(Hdrs, RD=#wm_reqdata{resp_headers=RespH}) -&gt;
<font color=red>     0..|      F = fun({K, V}, Acc) -&gt; mochiweb_headers:insert(K, V, Acc) end,</font>
<font color=red>     0..|      NewHdrs = lists:foldl(F, RespH, Hdrs),</font>
<font color=red>     0..|      RD#wm_reqdata{resp_headers=NewHdrs}.</font>
        |  
<font color=red>     0..|  append_to_resp_body(Data, RD) -&gt; append_to_response_body(Data, RD).</font>
        |  append_to_response_body(Data, RD=#wm_reqdata{resp_body=RespB}) -&gt;
<font color=red>     0..|      case is_binary(Data) of</font>
        |          true -&gt;
<font color=red>     0..|              Data0 = RespB,</font>
<font color=red>     0..|              Data1 = &lt;&lt;Data0/binary,Data/binary&gt;&gt;,</font>
<font color=red>     0..|              RD#wm_reqdata{resp_body=Data1};</font>
        |          false -&gt; % MUST BE an iolist! else, fail.
<font color=red>     0..|              append_to_response_body(iolist_to_binary(Data), RD)</font>
        |      end.
        |  
        |  get_cookie_value(Key, RD) when is_list(Key) -&gt; % string
     1..|      proplists:get_value(Key, req_cookie(RD)).
        |  
        |  get_qs_value(Key, RD) when is_list(Key) -&gt; % string
     2..|      proplists:get_value(Key, req_qs(RD)).
        |  
        |  get_qs_value(Key, Default, RD) when is_list(Key) -&gt;
     1..|      proplists:get_value(Key, req_qs(RD), Default).
        |  
<font color=red>     0..|  add_note(K, V, RD) -&gt; RD#wm_reqdata{notes=[{K, V} | RD#wm_reqdata.notes]}.</font>
        |  
<font color=red>     0..|  get_notes(RD) -&gt; RD#wm_reqdata.notes.</font>
        |  
        |  make_wrq(Method, RawPath, Headers) -&gt;
     2..|      create(Method, {1,1}, RawPath, mochiweb_headers:from_list(Headers)).
        |  
        |  accessor_test() -&gt;
     1..|      R0 = make_wrq('GET', "/foo?a=1&b=2", [{"Cookie", "foo=bar"}]),
     1..|      R = set_peer("127.0.0.1", R0),
     1..|      ?assertEqual('GET', method(R)),
     1..|      ?assertEqual({1,1}, version(R)),
     1..|      ?assertEqual("/foo", path(R)),
     1..|      ?assertEqual("/foo?a=1&b=2", raw_path(R)),     
     1..|      ?assertEqual([{"a", "1"}, {"b", "2"}], req_qs(R)),
     1..|      ?assertEqual({"1", "2"}, {get_qs_value("a", R), get_qs_value("b", R)}),
     1..|      ?assertEqual("3", get_qs_value("c", "3", R)),
     1..|      ?assertEqual([{"foo", "bar"}], req_cookie(R)),
     1..|      ?assertEqual("bar", get_cookie_value("foo", R)),
     1..|      ?assertEqual("127.0.0.1", peer(R)).
        |  
        |      
        |  simple_dispatch_test() -&gt;
     1..|      R0 = make_wrq('GET', "/foo?a=1&b=2", [{"Cookie", "foo=bar"}]),
     1..|      R1 = set_peer("127.0.0.1", R0),    
     1..|      {_, _, HostTokens, Port, PathTokens, Bindings, AppRoot, StringPath} = 
        |          webmachine_dispatcher:dispatch("127.0.0.1", "/foo", 
        |                                         [{["foo"], foo_resource, []}]),
     1..|      R = load_dispatch_data(Bindings,
        |                             HostTokens,
        |                             Port,
        |                             PathTokens,
        |                             AppRoot,
        |                             StringPath,
        |                             R1),
     1..|      ?assertEqual(".", app_root(R)),
     1..|      ?assertEqual(80, port(R)).
</pre>
</body>
</html>
