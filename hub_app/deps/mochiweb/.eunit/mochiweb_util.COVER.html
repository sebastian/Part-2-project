<html>
<head><title>.eunit/mochiweb_util.COVER.html</title></head><body bgcolor=white text=black>
<pre>
File generated from /Users/seb/Documents/part2project/app/deps/mochiweb/.eunit/mochiweb_util.erl by COVER 2010-10-28 at 14:19:50

****************************************************************************

        |  %% @author Bob Ippolito &lt;bob@mochimedia.com&gt;
        |  %% @copyright 2007 Mochi Media, Inc.
        |  
        |  %% @doc Utilities for parsing and quoting.
        |  
        |  -module(mochiweb_util).
        |  -author('bob@mochimedia.com').
        |  -export([join/2, quote_plus/1, urlencode/1, parse_qs/1, unquote/1]).
        |  -export([path_split/1]).
        |  -export([urlsplit/1, urlsplit_path/1, urlunsplit/1, urlunsplit_path/1]).
        |  -export([guess_mime/1, parse_header/1]).
        |  -export([shell_quote/1, cmd/1, cmd_string/1, cmd_port/2, cmd_status/1]).
        |  -export([record_to_proplist/2, record_to_proplist/3]).
        |  -export([safe_relative_path/1, partition/2]).
        |  -export([parse_qvalues/1, pick_accepted_encodings/3]).
        |  -export([make_io/1]).
        |  
        |  -define(PERCENT, 37).  % $\%
        |  -define(FULLSTOP, 46). % $\.
        |  -define(IS_HEX(C), ((C &gt;= $0 andalso C =&lt; $9) orelse
        |                      (C &gt;= $a andalso C =&lt; $f) orelse
        |                      (C &gt;= $A andalso C =&lt; $F))).
        |  -define(QS_SAFE(C), ((C &gt;= $a andalso C =&lt; $z) orelse
        |                       (C &gt;= $A andalso C =&lt; $Z) orelse
        |                       (C &gt;= $0 andalso C =&lt; $9) orelse
        |                       (C =:= ?FULLSTOP orelse C =:= $- orelse C =:= $~ orelse
        |                        C =:= $_))).
        |  
    12..|  hexdigit(C) when C &lt; 10 -&gt; $0 + C;
     8..|  hexdigit(C) when C &lt; 16 -&gt; $A + (C - 10).
        |  
    14..|  unhexdigit(C) when C &gt;= $0, C =&lt; $9 -&gt; C - $0;
     3..|  unhexdigit(C) when C &gt;= $a, C =&lt; $f -&gt; C - $a + 10;
     7..|  unhexdigit(C) when C &gt;= $A, C =&lt; $F -&gt; C - $A + 10.
        |  
        |  %% @spec partition(String, Sep) -&gt; {String, [], []} | {Prefix, Sep, Postfix}
        |  %% @doc Inspired by Python 2.5's str.partition:
        |  %%      partition("foo/bar", "/") = {"foo", "/", "bar"},
        |  %%      partition("foo", "/") = {"foo", "", ""}.
        |  partition(String, Sep) -&gt;
    26..|      case partition(String, Sep, []) of
        |          undefined -&gt;
     6..|              {String, "", ""};
        |          Result -&gt;
    20..|              Result
        |      end.
        |  
        |  partition("", _Sep, _Acc) -&gt;
     6..|      undefined;
        |  partition(S, Sep, Acc) -&gt;
    82..|      case partition2(S, Sep) of
        |          undefined -&gt;
    62..|              [C | Rest] = S,
    62..|              partition(Rest, Sep, [C | Acc]);
        |          Rest -&gt;
    20..|              {lists:reverse(Acc), Sep, Rest}
        |      end.
        |  
        |  partition2(Rest, "") -&gt;
    20..|      Rest;
        |  partition2([C | R1], [C | R2]) -&gt;
    24..|      partition2(R1, R2);
        |  partition2(_S, _Sep) -&gt;
    62..|      undefined.
        |  
        |  
        |  
        |  %% @spec safe_relative_path(string()) -&gt; string() | undefined
        |  %% @doc Return the reduced version of a relative path or undefined if it
        |  %%      is not safe. safe relative paths can be joined with an absolute path
        |  %%      and will result in a subdirectory of the absolute path.
        |  safe_relative_path("/" ++ _) -&gt;
     1..|      undefined;
        |  safe_relative_path(P) -&gt;
    10..|      safe_relative_path(P, []).
        |  
        |  safe_relative_path("", Acc) -&gt;
     7..|      case Acc of
        |          [] -&gt;
     2..|              "";
        |          _ -&gt;
     5..|              string:join(lists:reverse(Acc), "/")
        |      end;
        |  safe_relative_path(P, Acc) -&gt;
    21..|      case partition(P, "/") of
        |          {"", "/", _} -&gt;
        |              %% /foo or foo//bar
     1..|              undefined;
        |          {"..", _, _} when Acc =:= [] -&gt;
     2..|              undefined;
        |          {"..", _, Rest} -&gt;
     6..|              safe_relative_path(Rest, tl(Acc));
        |          {Part, "/", ""} -&gt;
     2..|              safe_relative_path("", ["", Part | Acc]);
        |          {Part, _, Rest} -&gt;
    10..|              safe_relative_path(Rest, [Part | Acc])
        |      end.
        |  
        |  %% @spec shell_quote(string()) -&gt; string()
        |  %% @doc Quote a string according to UNIX shell quoting rules, returns a string
        |  %%      surrounded by double quotes.
        |  shell_quote(L) -&gt;
     9..|      shell_quote(L, [$\"]).
        |  
        |  %% @spec cmd_port([string()], Options) -&gt; port()
        |  %% @doc open_port({spawn, mochiweb_util:cmd_string(Argv)}, Options).
        |  cmd_port(Argv, Options) -&gt;
     2..|      open_port({spawn, cmd_string(Argv)}, Options).
        |  
        |  %% @spec cmd([string()]) -&gt; string()
        |  %% @doc os:cmd(cmd_string(Argv)).
        |  cmd(Argv) -&gt;
     1..|      os:cmd(cmd_string(Argv)).
        |  
        |  %% @spec cmd_string([string()]) -&gt; string()
        |  %% @doc Create a shell quoted command string from a list of arguments.
        |  cmd_string(Argv) -&gt;
     4..|      string:join([shell_quote(X) || X &lt;- Argv], " ").
        |  
        |  %% @spec cmd_status([string()]) -&gt; {ExitStatus::integer(), Stdout::binary()}
        |  %% @doc Accumulate the output and exit status from the given application, will be
        |  %%      spawned with cmd_port/2.
        |  cmd_status(Argv) -&gt;
     1..|      Port = cmd_port(Argv, [exit_status, stderr_to_stdout,
        |                             use_stdio, binary]),
     1..|      try cmd_loop(Port, [])
     1..|      after catch port_close(Port)
        |      end.
        |  
        |  %% @spec cmd_loop(port(), list()) -&gt; {ExitStatus::integer(), Stdout::binary()}
        |  %% @doc Accumulate the output and exit status from a port.
        |  cmd_loop(Port, Acc) -&gt;
     2..|      receive
        |          {Port, {exit_status, Status}} -&gt;
     1..|              {Status, iolist_to_binary(lists:reverse(Acc))};
        |          {Port, {data, Data}} -&gt;
     1..|              cmd_loop(Port, [Data | Acc])
        |      end.
        |  
        |  %% @spec join([iolist()], iolist()) -&gt; iolist()
        |  %% @doc Join a list of strings or binaries together with the given separator
        |  %%      string or char or binary. The output is flattened, but may be an
        |  %%      iolist() instead of a string() if any of the inputs are binary().
        |  join([], _Separator) -&gt;
     1..|      [];
        |  join([S], _Separator) -&gt;
     2..|      lists:flatten(S);
        |  join(Strings, Separator) -&gt;
    16..|      lists:flatten(revjoin(lists:reverse(Strings), Separator, [])).
        |  
        |  revjoin([], _Separator, Acc) -&gt;
    16..|      Acc;
        |  revjoin([S | Rest], Separator, []) -&gt;
    16..|      revjoin(Rest, Separator, [S]);
        |  revjoin([S | Rest], Separator, Acc) -&gt;
    95..|      revjoin(Rest, Separator, [S, Separator | Acc]).
        |  
        |  %% @spec quote_plus(atom() | integer() | float() | string() | binary()) -&gt; string()
        |  %% @doc URL safe encoding of the given term.
        |  quote_plus(Atom) when is_atom(Atom) -&gt;
     3..|      quote_plus(atom_to_list(Atom));
        |  quote_plus(Int) when is_integer(Int) -&gt;
     2..|      quote_plus(integer_to_list(Int));
        |  quote_plus(Binary) when is_binary(Binary) -&gt;
     1..|      quote_plus(binary_to_list(Binary));
        |  quote_plus(Float) when is_float(Float) -&gt;
     1..|      quote_plus(mochinum:digits(Float));
        |  quote_plus(String) -&gt;
    15..|      quote_plus(String, []).
        |  
        |  quote_plus([], Acc) -&gt;
    15..|      lists:reverse(Acc);
        |  quote_plus([C | Rest], Acc) when ?QS_SAFE(C) -&gt;
    45..|      quote_plus(Rest, [C | Acc]);
        |  quote_plus([$\s | Rest], Acc) -&gt;
     2..|      quote_plus(Rest, [$+ | Acc]);
        |  quote_plus([C | Rest], Acc) -&gt;
    10..|      &lt;&lt;Hi:4, Lo:4&gt;&gt; = &lt;&lt;C&gt;&gt;,
    10..|      quote_plus(Rest, [hexdigit(Lo), hexdigit(Hi), ?PERCENT | Acc]).
        |  
        |  %% @spec urlencode([{Key, Value}]) -&gt; string()
        |  %% @doc URL encode the property list.
        |  urlencode(Props) -&gt;
     1..|      Pairs = lists:foldr(
        |                fun ({K, V}, Acc) -&gt;
     3..|                        [quote_plus(K) ++ "=" ++ quote_plus(V) | Acc]
        |                end, [], Props),
     1..|      string:join(Pairs, "&").
        |  
        |  %% @spec parse_qs(string() | binary()) -&gt; [{Key, Value}]
        |  %% @doc Parse a query string or application/x-www-form-urlencoded.
        |  parse_qs(Binary) when is_binary(Binary) -&gt;
     1..|      parse_qs(binary_to_list(Binary));
        |  parse_qs(String) -&gt;
     5..|      parse_qs(String, []).
        |  
        |  parse_qs([], Acc) -&gt;
     5..|      lists:reverse(Acc);
        |  parse_qs(String, Acc) -&gt;
    12..|      {Key, Rest} = parse_qs_key(String),
    12..|      {Value, Rest1} = parse_qs_value(Rest),
    12..|      parse_qs(Rest1, [{Key, Value} | Acc]).
        |  
        |  parse_qs_key(String) -&gt;
    12..|      parse_qs_key(String, []).
        |  
        |  parse_qs_key([], Acc) -&gt;
     1..|      {qs_revdecode(Acc), ""};
        |  parse_qs_key([$= | Rest], Acc) -&gt;
     9..|      {qs_revdecode(Acc), Rest};
        |  parse_qs_key(Rest=[$; | _], Acc) -&gt;
     1..|      {qs_revdecode(Acc), Rest};
        |  parse_qs_key(Rest=[$& | _], Acc) -&gt;
     1..|      {qs_revdecode(Acc), Rest};
        |  parse_qs_key([C | Rest], Acc) -&gt;
    27..|      parse_qs_key(Rest, [C | Acc]).
        |  
        |  parse_qs_value(String) -&gt;
    12..|      parse_qs_value(String, []).
        |  
        |  parse_qs_value([], Acc) -&gt;
     4..|      {qs_revdecode(Acc), ""};
        |  parse_qs_value([$; | Rest], Acc) -&gt;
     1..|      {qs_revdecode(Acc), Rest};
        |  parse_qs_value([$& | Rest], Acc) -&gt;
     7..|      {qs_revdecode(Acc), Rest};
        |  parse_qs_value([C | Rest], Acc) -&gt;
    50..|      parse_qs_value(Rest, [C | Acc]).
        |  
        |  %% @spec unquote(string() | binary()) -&gt; string()
        |  %% @doc Unquote a URL encoded string.
        |  unquote(Binary) when is_binary(Binary) -&gt;
     1..|      unquote(binary_to_list(Binary));
        |  unquote(String) -&gt;
   213..|      qs_revdecode(lists:reverse(String)).
        |  
        |  qs_revdecode(S) -&gt;
   237..|      qs_revdecode(S, []).
        |  
        |  qs_revdecode([], Acc) -&gt;
   237..|      Acc;
        |  qs_revdecode([$+ | Rest], Acc) -&gt;
     5..|      qs_revdecode(Rest, [$\s | Acc]);
        |  qs_revdecode([Lo, Hi, ?PERCENT | Rest], Acc) when ?IS_HEX(Lo), ?IS_HEX(Hi) -&gt;
    12..|      qs_revdecode(Rest, [(unhexdigit(Lo) bor (unhexdigit(Hi) bsl 4)) | Acc]);
        |  qs_revdecode([C | Rest], Acc) -&gt;
  2568..|      qs_revdecode(Rest, [C | Acc]).
        |  
        |  %% @spec urlsplit(Url) -&gt; {Scheme, Netloc, Path, Query, Fragment}
        |  %% @doc Return a 5-tuple, does not expand % escapes. Only supports HTTP style
        |  %%      URLs.
        |  urlsplit(Url) -&gt;
     4..|      {Scheme, Url1} = urlsplit_scheme(Url),
     4..|      {Netloc, Url2} = urlsplit_netloc(Url1),
     4..|      {Path, Query, Fragment} = urlsplit_path(Url2),
     4..|      {Scheme, Netloc, Path, Query, Fragment}.
        |  
        |  urlsplit_scheme(Url) -&gt;
     4..|      case urlsplit_scheme(Url, []) of
        |          no_scheme -&gt;
     2..|              {"", Url};
        |          Res -&gt;
     2..|              Res
        |      end.
        |  
        |  urlsplit_scheme([C | Rest], Acc) when ((C &gt;= $a andalso C =&lt; $z) orelse
        |                                         (C &gt;= $A andalso C =&lt; $Z) orelse
        |                                         (C &gt;= $0 andalso C =&lt; $9) orelse
        |                                         C =:= $+ orelse C =:= $- orelse
        |                                         C =:= $.) -&gt;
     8..|      urlsplit_scheme(Rest, [C | Acc]);
        |  urlsplit_scheme([$: | Rest], Acc=[_ | _]) -&gt;
     2..|      {string:to_lower(lists:reverse(Acc)), Rest};
        |  urlsplit_scheme(_Rest, _Acc) -&gt;
     2..|      no_scheme.
        |  
        |  urlsplit_netloc("//" ++ Rest) -&gt;
     2..|      urlsplit_netloc(Rest, []);
        |  urlsplit_netloc(Path) -&gt;
     2..|      {"", Path}.
        |  
        |  urlsplit_netloc("", Acc) -&gt;
     1..|      {lists:reverse(Acc), ""};
        |  urlsplit_netloc(Rest=[C | _], Acc) when C =:= $/; C =:= $?; C =:= $# -&gt;
     1..|      {lists:reverse(Acc), Rest};
        |  urlsplit_netloc([C | Rest], Acc) -&gt;
    13..|      urlsplit_netloc(Rest, [C | Acc]).
        |  
        |  
        |  %% @spec path_split(string()) -&gt; {Part, Rest}
        |  %% @doc Split a path starting from the left, as in URL traversal.
        |  %%      path_split("foo/bar") = {"foo", "bar"},
        |  %%      path_split("/foo/bar") = {"", "foo/bar"}.
        |  path_split(S) -&gt;
     3..|      path_split(S, []).
        |  
        |  path_split("", Acc) -&gt;
     1..|      {lists:reverse(Acc), ""};
        |  path_split("/" ++ Rest, Acc) -&gt;
     2..|      {lists:reverse(Acc), Rest};
        |  path_split([C | Rest], Acc) -&gt;
     6..|      path_split(Rest, [C | Acc]).
        |  
        |  
        |  %% @spec urlunsplit({Scheme, Netloc, Path, Query, Fragment}) -&gt; string()
        |  %% @doc Assemble a URL from the 5-tuple. Path must be absolute.
        |  urlunsplit({Scheme, Netloc, Path, Query, Fragment}) -&gt;
     2..|      lists:flatten([case Scheme of "" -&gt; "";  _ -&gt; [Scheme, "://"] end,
        |                     Netloc,
        |                     urlunsplit_path({Path, Query, Fragment})]).
        |  
        |  %% @spec urlunsplit_path({Path, Query, Fragment}) -&gt; string()
        |  %% @doc Assemble a URL path from the 3-tuple.
        |  urlunsplit_path({Path, Query, Fragment}) -&gt;
     8..|      lists:flatten([Path,
     8..|                     case Query of "" -&gt; ""; _ -&gt; [$? | Query] end,
     8..|                     case Fragment of "" -&gt; ""; _ -&gt; [$# | Fragment] end]).
        |  
        |  %% @spec urlsplit_path(Url) -&gt; {Path, Query, Fragment}
        |  %% @doc Return a 3-tuple, does not expand % escapes. Only supports HTTP style
        |  %%      paths.
        |  urlsplit_path(Path) -&gt;
   219..|      urlsplit_path(Path, []).
        |  
        |  urlsplit_path("", Acc) -&gt;
   211..|      {lists:reverse(Acc), "", ""};
        |  urlsplit_path("?" ++ Rest, Acc) -&gt;
     4..|      {Query, Fragment} = urlsplit_query(Rest),
     4..|      {lists:reverse(Acc), Query, Fragment};
        |  urlsplit_path("#" ++ Rest, Acc) -&gt;
     4..|      {lists:reverse(Acc), "", Rest};
        |  urlsplit_path([C | Rest], Acc) -&gt;
  2554..|      urlsplit_path(Rest, [C | Acc]).
        |  
        |  urlsplit_query(Query) -&gt;
     4..|      urlsplit_query(Query, []).
        |  
        |  urlsplit_query("", Acc) -&gt;
     2..|      {lists:reverse(Acc), ""};
        |  urlsplit_query("#" ++ Rest, Acc) -&gt;
     2..|      {lists:reverse(Acc), Rest};
        |  urlsplit_query([C | Rest], Acc) -&gt;
    17..|      urlsplit_query(Rest, [C | Acc]).
        |  
        |  %% @spec guess_mime(string()) -&gt; string()
        |  %% @doc  Guess the mime type of a file by the extension of its filename.
        |  guess_mime(File) -&gt;
     6..|      case mochiweb_mime:from_extension(filename:extension(File)) of
        |          undefined -&gt;
     2..|              "text/plain";
        |          Mime -&gt;
     4..|              Mime
        |      end.
        |  
        |  %% @spec parse_header(string()) -&gt; {Type, [{K, V}]}
        |  %% @doc  Parse a Content-Type like header, return the main Content-Type
        |  %%       and a property list of options.
        |  parse_header(String) -&gt;
        |      %% TODO: This is exactly as broken as Python's cgi module.
        |      %%       Should parse properly like mochiweb_cookies.
    88..|      [Type | Parts] = [string:strip(S) || S &lt;- string:tokens(String, ";")],
    88..|      F = fun (S, Acc) -&gt;
    90..|                  case lists:splitwith(fun (C) -&gt; C =/= $= end, S) of
        |                      {"", _} -&gt;
        |                          %% Skip anything with no name
     1..|                          Acc;
        |                      {_, ""} -&gt;
        |                          %% Skip anything with no value
     1..|                          Acc;
        |                      {Name, [$\= | Value]} -&gt;
    88..|                          [{string:to_lower(string:strip(Name)),
        |                            unquote_header(string:strip(Value))} | Acc]
        |                  end
        |          end,
    88..|      {string:to_lower(Type),
        |       lists:foldr(F, [], Parts)}.
        |  
        |  unquote_header("\"" ++ Rest) -&gt;
    57..|      unquote_header(Rest, []);
        |  unquote_header(S) -&gt;
    31..|      S.
        |  
        |  unquote_header("", Acc) -&gt;
     1..|      lists:reverse(Acc);
        |  unquote_header("\"", Acc) -&gt;
    56..|      lists:reverse(Acc);
        |  unquote_header([$\\, C | Rest], Acc) -&gt;
     1..|      unquote_header(Rest, [C | Acc]);
        |  unquote_header([C | Rest], Acc) -&gt;
   459..|      unquote_header(Rest, [C | Acc]).
        |  
        |  %% @spec record_to_proplist(Record, Fields) -&gt; proplist()
        |  %% @doc calls record_to_proplist/3 with a default TypeKey of '__record'
        |  record_to_proplist(Record, Fields) -&gt;
     1..|      record_to_proplist(Record, Fields, '__record').
        |  
        |  %% @spec record_to_proplist(Record, Fields, TypeKey) -&gt; proplist()
        |  %% @doc Return a proplist of the given Record with each field in the
        |  %%      Fields list set as a key with the corresponding value in the Record.
        |  %%      TypeKey is the key that is used to store the record type
        |  %%      Fields should be obtained by calling record_info(fields, record_type)
        |  %%      where record_type is the record type of Record
        |  record_to_proplist(Record, Fields, TypeKey)
        |    when tuple_size(Record) - 1 =:= length(Fields) -&gt;
     2..|      lists:zip([TypeKey | Fields], tuple_to_list(Record)).
        |  
        |  
        |  shell_quote([], Acc) -&gt;
     9..|      lists:reverse([$\" | Acc]);
        |  shell_quote([C | Rest], Acc) when C =:= $\" orelse C =:= $\` orelse
        |                                    C =:= $\\ orelse C =:= $\$ -&gt;
    19..|      shell_quote(Rest, [C, $\\ | Acc]);
        |  shell_quote([C | Rest], Acc) -&gt;
    72..|      shell_quote(Rest, [C | Acc]).
        |  
        |  %% @spec parse_qvalues(string()) -&gt; [qvalue()] | invalid_qvalue_string
        |  %% @type qvalue() = {encoding(), float()}.
        |  %% @type encoding() = string().
        |  %%
        |  %% @doc Parses a list (given as a string) of elements with Q values associated
        |  %%      to them. Elements are separated by commas and each element is separated
        |  %%      from its Q value by a semicolon. Q values are optional but when missing
        |  %%      the value of an element is considered as 1.0. A Q value is always in the
        |  %%      range [0.0, 1.0]. A Q value list is used for example as the value of the
        |  %%      HTTP "Accept-Encoding" header.
        |  %%
        |  %%      Q values are described in section 2.9 of the RFC 2616 (HTTP 1.1).
        |  %%
        |  %%      Example:
        |  %%
        |  %%      parse_qvalues("gzip; q=0.5, deflate, identity;q=0.0") -&gt;
        |  %%          [{"gzip", 0.5}, {"deflate", 1.0}, {"identity", 0.0}]
        |  %%
        |  parse_qvalues(QValuesStr) -&gt;
    21..|      try
    21..|          {ok, Re} = re:compile("^\\s*q\\s*=\\s*((?:0|1)(?:\\.\\d{1,3})?)\\s*$"),
    21..|          lists:map(
        |              fun(Pair) -&gt;
    44..|                  case string:tokens(Pair, ";") of
        |                      [Enc] -&gt;
    16..|                          {string:strip(Enc), 1.0};
        |                      [Enc, QStr] -&gt;
    28..|                          case re:run(QStr, Re, [{capture, [1], list}]) of
        |                              {match, [Q]} -&gt;
    24..|                                  QVal = case Q of
        |                                      "0" -&gt;
     6..|                                          0.0;
        |                                      "1" -&gt;
     1..|                                          1.0;
        |                                      Else -&gt;
    17..|                                          list_to_float(Else)
        |                                  end,
    24..|                                  case QVal &lt; 0.0 orelse QVal &gt; 1.0 of
        |                                      false -&gt;
    23..|                                          {string:strip(Enc), QVal}
        |                                  end
        |                          end
        |                  end
        |              end,
        |              string:tokens(string:to_lower(QValuesStr), ",")
        |          )
        |      catch
        |          _Type:_Error -&gt;
     5..|              invalid_qvalue_string
        |      end.
        |  
        |  %% @spec pick_accepted_encodings([qvalue()], [encoding()], encoding()) -&gt;
        |  %%    [encoding()]
        |  %%
        |  %% @doc Determines which encodings specified in the given Q values list are
        |  %%      valid according to a list of supported encodings and a default encoding.
        |  %%
        |  %%      The returned list of encodings is sorted, descendingly, according to the
        |  %%      Q values of the given list. The last element of this list is the given
        |  %%      default encoding unless this encoding is explicitily or implicitily
        |  %%      marked with a Q value of 0.0 in the given Q values list.
        |  %%      Note: encodings with the same Q value are kept in the same order as
        |  %%            found in the input Q values list.
        |  %%
        |  %%      This encoding picking process is described in section 14.3 of the
        |  %%      RFC 2616 (HTTP 1.1).
        |  %%
        |  %%      Example:
        |  %%
        |  %%      pick_accepted_encodings(
        |  %%          [{"gzip", 0.5}, {"deflate", 1.0}],
        |  %%          ["gzip", "identity"],
        |  %%          "identity"
        |  %%      ) -&gt;
        |  %%          ["gzip", "identity"]
        |  %%
        |  pick_accepted_encodings(AcceptedEncs, SupportedEncs, DefaultEnc) -&gt;
    21..|      SortedQList = lists:reverse(
    25..|          lists:sort(fun({_, Q1}, {_, Q2}) -&gt; Q1 &lt; Q2 end, AcceptedEncs)
        |      ),
    21..|      {Accepted, Refused} = lists:foldr(
        |          fun({E, Q}, {A, R}) -&gt;
    42..|              case Q &gt; 0.0 of
        |                  true -&gt;
    31..|                      {[E | A], R};
        |                  false -&gt;
    11..|                      {A, [E | R]}
        |              end
        |          end,
        |          {[], []},
        |          SortedQList
        |      ),
    21..|      Refused1 = lists:foldr(
        |          fun(Enc, Acc) -&gt;
    11..|              case Enc of
        |                  "*" -&gt;
     4..|                      lists:subtract(SupportedEncs, Accepted) ++ Acc;
        |                  _ -&gt;
     7..|                      [Enc | Acc]
        |              end
        |          end,
        |          [],
        |          Refused
        |      ),
    21..|      Accepted1 = lists:foldr(
        |          fun(Enc, Acc) -&gt;
    31..|              case Enc of
        |                  "*" -&gt;
     4..|                      lists:subtract(SupportedEncs, Accepted ++ Refused1) ++ Acc;
        |                  _ -&gt;
    27..|                      [Enc | Acc]
        |              end
        |          end,
        |          [],
        |          Accepted
        |      ),
    21..|      Accepted2 = case lists:member(DefaultEnc, Accepted1) of
        |          true -&gt;
     4..|              Accepted1;
        |          false -&gt;
    17..|              Accepted1 ++ [DefaultEnc]
        |      end,
    21..|      [E || E &lt;- Accepted2, lists:member(E, SupportedEncs),
    51..|          not lists:member(E, Refused1)].
        |  
        |  make_io(Atom) when is_atom(Atom) -&gt;
     1..|      atom_to_list(Atom);
        |  make_io(Integer) when is_integer(Integer) -&gt;
    28..|      integer_to_list(Integer);
        |  make_io(Io) when is_list(Io); is_binary(Io) -&gt;
  1682..|      Io.
        |  
        |  %%
        |  %% Tests
        |  %%
        |  -include_lib("eunit/include/eunit.hrl").
        |  -ifdef(TEST).
        |  
        |  make_io_test() -&gt;
     1..|      ?assertEqual(
        |         &lt;&lt;"atom"&gt;&gt;,
     1..|         iolist_to_binary(make_io(atom))),
     1..|      ?assertEqual(
        |         &lt;&lt;"20"&gt;&gt;,
     1..|         iolist_to_binary(make_io(20))),
     1..|      ?assertEqual(
        |         &lt;&lt;"list"&gt;&gt;,
     1..|         iolist_to_binary(make_io("list"))),
     1..|      ?assertEqual(
        |         &lt;&lt;"binary"&gt;&gt;,
     1..|         iolist_to_binary(make_io(&lt;&lt;"binary"&gt;&gt;))),
     1..|      ok.
        |  
        |  -record(test_record, {field1=f1, field2=f2}).
        |  record_to_proplist_test() -&gt;
     1..|      ?assertEqual(
        |         [{'__record', test_record},
        |          {field1, f1},
        |          {field2, f2}],
     1..|         record_to_proplist(#test_record{}, record_info(fields, test_record))),
     1..|      ?assertEqual(
        |         [{'typekey', test_record},
        |          {field1, f1},
        |          {field2, f2}],
        |         record_to_proplist(#test_record{},
        |                            record_info(fields, test_record),
     1..|                            typekey)),
     1..|      ok.
        |  
        |  shell_quote_test() -&gt;
     1..|      ?assertEqual(
        |         "\"foo \\$bar\\\"\\`' baz\"",
     1..|         shell_quote("foo $bar\"`' baz")),
     1..|      ok.
        |  
        |  cmd_port_test_spool(Port, Acc) -&gt;
     4..|      receive
        |          {Port, eof} -&gt;
     1..|              Acc;
        |          {Port, {data, {eol, Data}}} -&gt;
     1..|              cmd_port_test_spool(Port, ["\n", Data | Acc]);
        |          {Port, Unknown} -&gt;
     1..|              throw({unknown, Unknown})
        |      after 100 -&gt;
     1..|              throw(timeout)
        |      end.
        |  
        |  cmd_port_test() -&gt;
     1..|      Port = cmd_port(["echo", "$bling$ `word`!"],
        |                      [eof, stream, {line, 4096}]),
     1..|      Res = try lists:append(lists:reverse(cmd_port_test_spool(Port, [])))
     1..|            after catch port_close(Port)
        |            end,
     1..|      self() ! {Port, wtf},
     1..|      try cmd_port_test_spool(Port, [])
     1..|      catch throw:{unknown, wtf} -&gt; ok
        |      end,
     1..|      try cmd_port_test_spool(Port, [])
     1..|      catch throw:timeout -&gt; ok
        |      end,
     1..|      ?assertEqual(
        |         "$bling$ `word`!\n",
     1..|         Res).
        |  
        |  cmd_test() -&gt;
     1..|      ?assertEqual(
        |         "$bling$ `word`!\n",
     1..|         cmd(["echo", "$bling$ `word`!"])),
     1..|      ok.
        |  
        |  cmd_string_test() -&gt;
     1..|      ?assertEqual(
        |         "\"echo\" \"\\$bling\\$ \\`word\\`!\"",
     1..|         cmd_string(["echo", "$bling$ `word`!"])),
     1..|      ok.
        |  
        |  cmd_status_test() -&gt;
     1..|      ?assertEqual(
        |         {0, &lt;&lt;"$bling$ `word`!\n"&gt;&gt;},
     1..|         cmd_status(["echo", "$bling$ `word`!"])),
     1..|      ok.
        |  
        |  
        |  parse_header_test() -&gt;
     1..|      ?assertEqual(
        |         {"multipart/form-data", [{"boundary", "AaB03x"}]},
     1..|         parse_header("multipart/form-data; boundary=AaB03x")),
        |      %% This tests (currently) intentionally broken behavior
     1..|      ?assertEqual(
        |         {"multipart/form-data",
        |          [{"b", ""},
        |           {"cgi", "is"},
        |           {"broken", "true\"e"}]},
     1..|         parse_header("multipart/form-data;b=;cgi=\"i\\s;broken=true\"e;=z;z")),
     1..|      ok.
        |  
        |  guess_mime_test() -&gt;
     1..|      "text/plain" = guess_mime(""),
     1..|      "text/plain" = guess_mime(".text"),
     1..|      "application/zip" = guess_mime(".zip"),
     1..|      "application/zip" = guess_mime("x.zip"),
     1..|      "text/html" = guess_mime("x.html"),
     1..|      "application/xhtml+xml" = guess_mime("x.xhtml"),
     1..|      ok.
        |  
        |  path_split_test() -&gt;
     1..|      {"", "foo/bar"} = path_split("/foo/bar"),
     1..|      {"foo", "bar"} = path_split("foo/bar"),
     1..|      {"bar", ""} = path_split("bar"),
     1..|      ok.
        |  
        |  urlsplit_test() -&gt;
     1..|      {"", "", "/foo", "", "bar?baz"} = urlsplit("/foo#bar?baz"),
     1..|      {"http", "host:port", "/foo", "", "bar?baz"} =
        |          urlsplit("http://host:port/foo#bar?baz"),
     1..|      {"http", "host", "", "", ""} = urlsplit("http://host"),
     1..|      {"", "", "/wiki/Category:Fruit", "", ""} =
        |          urlsplit("/wiki/Category:Fruit"),
     1..|      ok.
        |  
        |  urlsplit_path_test() -&gt;
     1..|      {"/foo/bar", "", ""} = urlsplit_path("/foo/bar"),
     1..|      {"/foo", "baz", ""} = urlsplit_path("/foo?baz"),
     1..|      {"/foo", "", "bar?baz"} = urlsplit_path("/foo#bar?baz"),
     1..|      {"/foo", "", "bar?baz#wibble"} = urlsplit_path("/foo#bar?baz#wibble"),
     1..|      {"/foo", "bar", "baz"} = urlsplit_path("/foo?bar#baz"),
     1..|      {"/foo", "bar?baz", "baz"} = urlsplit_path("/foo?bar?baz#baz"),
     1..|      ok.
        |  
        |  urlunsplit_test() -&gt;
     1..|      "/foo#bar?baz" = urlunsplit({"", "", "/foo", "", "bar?baz"}),
     1..|      "http://host:port/foo#bar?baz" =
        |          urlunsplit({"http", "host:port", "/foo", "", "bar?baz"}),
     1..|      ok.
        |  
        |  urlunsplit_path_test() -&gt;
     1..|      "/foo/bar" = urlunsplit_path({"/foo/bar", "", ""}),
     1..|      "/foo?baz" = urlunsplit_path({"/foo", "baz", ""}),
     1..|      "/foo#bar?baz" = urlunsplit_path({"/foo", "", "bar?baz"}),
     1..|      "/foo#bar?baz#wibble" = urlunsplit_path({"/foo", "", "bar?baz#wibble"}),
     1..|      "/foo?bar#baz" = urlunsplit_path({"/foo", "bar", "baz"}),
     1..|      "/foo?bar?baz#baz" = urlunsplit_path({"/foo", "bar?baz", "baz"}),
     1..|      ok.
        |  
        |  join_test() -&gt;
     1..|      ?assertEqual("foo,bar,baz",
     1..|                    join(["foo", "bar", "baz"], $,)),
     1..|      ?assertEqual("foo,bar,baz",
     1..|                    join(["foo", "bar", "baz"], ",")),
     1..|      ?assertEqual("foo bar",
     1..|                    join([["foo", " bar"]], ",")),
     1..|      ?assertEqual("foo bar,baz",
     1..|                    join([["foo", " bar"], "baz"], ",")),
     1..|      ?assertEqual("foo",
     1..|                    join(["foo"], ",")),
     1..|      ?assertEqual("foobarbaz",
     1..|                    join(["foo", "bar", "baz"], "")),
     1..|      ?assertEqual("foo" ++ [&lt;&lt;&gt;&gt;] ++ "bar" ++ [&lt;&lt;&gt;&gt;] ++ "baz",
     1..|                   join(["foo", "bar", "baz"], &lt;&lt;&gt;&gt;)),
     1..|      ?assertEqual("foobar" ++ [&lt;&lt;"baz"&gt;&gt;],
     1..|                   join(["foo", "bar", &lt;&lt;"baz"&gt;&gt;], "")),
     1..|      ?assertEqual("",
     1..|                   join([], "any")),
     1..|      ok.
        |  
        |  quote_plus_test() -&gt;
     1..|      "foo" = quote_plus(foo),
     1..|      "1" = quote_plus(1),
     1..|      "1.1" = quote_plus(1.1),
     1..|      "foo" = quote_plus("foo"),
     1..|      "foo+bar" = quote_plus("foo bar"),
     1..|      "foo%0A" = quote_plus("foo\n"),
     1..|      "foo%0A" = quote_plus("foo\n"),
     1..|      "foo%3B%26%3D" = quote_plus("foo;&="),
     1..|      "foo%3B%26%3D" = quote_plus(&lt;&lt;"foo;&="&gt;&gt;),
     1..|      ok.
        |  
        |  unquote_test() -&gt;
     1..|      ?assertEqual("foo bar",
     1..|                   unquote("foo+bar")),
     1..|      ?assertEqual("foo bar",
     1..|                   unquote("foo%20bar")),
     1..|      ?assertEqual("foo\r\n",
     1..|                   unquote("foo%0D%0A")),
     1..|      ?assertEqual("foo\r\n",
     1..|                   unquote(&lt;&lt;"foo%0D%0A"&gt;&gt;)),
     1..|      ok.
        |  
        |  urlencode_test() -&gt;
     1..|      "foo=bar&baz=wibble+%0D%0A&z=1" = urlencode([{foo, "bar"},
        |                                                   {"baz", "wibble \r\n"},
        |                                                   {z, 1}]),
     1..|      ok.
        |  
        |  parse_qs_test() -&gt;
     1..|      ?assertEqual(
        |         [{"foo", "bar"}, {"baz", "wibble \r\n"}, {"z", "1"}],
     1..|         parse_qs("foo=bar&baz=wibble+%0D%0a&z=1")),
     1..|      ?assertEqual(
        |         [{"", "bar"}, {"baz", "wibble \r\n"}, {"z", ""}],
     1..|         parse_qs("=bar&baz=wibble+%0D%0a&z=")),
     1..|      ?assertEqual(
        |         [{"foo", "bar"}, {"baz", "wibble \r\n"}, {"z", "1"}],
     1..|         parse_qs(&lt;&lt;"foo=bar&baz=wibble+%0D%0a&z=1"&gt;&gt;)),
     1..|      ?assertEqual(
        |         [],
     1..|         parse_qs("")),
     1..|      ?assertEqual(
        |         [{"foo", ""}, {"bar", ""}, {"baz", ""}],
     1..|         parse_qs("foo;bar&baz")),
     1..|      ok.
        |  
        |  partition_test() -&gt;
     1..|      {"foo", "", ""} = partition("foo", "/"),
     1..|      {"foo", "/", "bar"} = partition("foo/bar", "/"),
     1..|      {"foo", "/", ""} = partition("foo/", "/"),
     1..|      {"", "/", "bar"} = partition("/bar", "/"),
     1..|      {"f", "oo/ba", "r"} = partition("foo/bar", "oo/ba"),
     1..|      ok.
        |  
        |  safe_relative_path_test() -&gt;
     1..|      "foo" = safe_relative_path("foo"),
     1..|      "foo/" = safe_relative_path("foo/"),
     1..|      "foo" = safe_relative_path("foo/bar/.."),
     1..|      "bar" = safe_relative_path("foo/../bar"),
     1..|      "bar/" = safe_relative_path("foo/../bar/"),
     1..|      "" = safe_relative_path("foo/.."),
     1..|      "" = safe_relative_path("foo/../"),
     1..|      undefined = safe_relative_path("/foo"),
     1..|      undefined = safe_relative_path("../foo"),
     1..|      undefined = safe_relative_path("foo/../.."),
     1..|      undefined = safe_relative_path("foo//"),
     1..|      ok.
        |  
        |  parse_qvalues_test() -&gt;
     1..|      [] = parse_qvalues(""),
     1..|      [{"identity", 0.0}] = parse_qvalues("identity;q=0"),
     1..|      [{"identity", 0.0}] = parse_qvalues("identity ;q=0"),
     1..|      [{"identity", 0.0}] = parse_qvalues(" identity; q =0 "),
     1..|      [{"identity", 0.0}] = parse_qvalues("identity ; q = 0"),
     1..|      [{"identity", 0.0}] = parse_qvalues("identity ; q= 0.0"),
     1..|      [{"gzip", 1.0}, {"deflate", 1.0}, {"identity", 0.0}] = parse_qvalues(
        |          "gzip,deflate,identity;q=0.0"
        |      ),
     1..|      [{"deflate", 1.0}, {"gzip", 1.0}, {"identity", 0.0}] = parse_qvalues(
        |          "deflate,gzip,identity;q=0.0"
        |      ),
     1..|      [{"gzip", 1.0}, {"deflate", 1.0}, {"gzip", 1.0}, {"identity", 0.0}] =
        |          parse_qvalues("gzip,deflate,gzip,identity;q=0"),
     1..|      [{"gzip", 1.0}, {"deflate", 1.0}, {"identity", 0.0}] = parse_qvalues(
        |          "gzip, deflate , identity; q=0.0"
        |      ),
     1..|      [{"gzip", 1.0}, {"deflate", 1.0}, {"identity", 0.0}] = parse_qvalues(
        |          "gzip; q=1, deflate;q=1.0, identity;q=0.0"
        |      ),
     1..|      [{"gzip", 0.5}, {"deflate", 1.0}, {"identity", 0.0}] = parse_qvalues(
        |          "gzip; q=0.5, deflate;q=1.0, identity;q=0"
        |      ),
     1..|      [{"gzip", 0.5}, {"deflate", 1.0}, {"identity", 0.0}] = parse_qvalues(
        |          "gzip; q=0.5, deflate , identity;q=0.0"
        |      ),
     1..|      [{"gzip", 0.5}, {"deflate", 0.8}, {"identity", 0.0}] = parse_qvalues(
        |          "gzip; q=0.5, deflate;q=0.8, identity;q=0.0"
        |      ),
     1..|      [{"gzip", 0.5}, {"deflate", 1.0}, {"identity", 1.0}] = parse_qvalues(
        |          "gzip; q=0.5,deflate,identity"
        |      ),
     1..|      [{"gzip", 0.5}, {"deflate", 1.0}, {"identity", 1.0}, {"identity", 1.0}] =
        |          parse_qvalues("gzip; q=0.5,deflate,identity, identity "),
     1..|      invalid_qvalue_string = parse_qvalues("gzip; q=1.1, deflate"),
     1..|      invalid_qvalue_string = parse_qvalues("gzip; q=0.5, deflate;q=2"),
     1..|      invalid_qvalue_string = parse_qvalues("gzip, deflate;q=AB"),
     1..|      invalid_qvalue_string = parse_qvalues("gzip; q=2.1, deflate"),
     1..|      invalid_qvalue_string = parse_qvalues("gzip; q=0.1234, deflate"),
     1..|      ok.
        |  
        |  pick_accepted_encodings_test() -&gt;
     1..|      ["identity"] = pick_accepted_encodings(
        |          [],
        |          ["gzip", "identity"],
        |          "identity"
        |      ),
     1..|      ["gzip", "identity"] = pick_accepted_encodings(
        |          [{"gzip", 1.0}],
        |          ["gzip", "identity"],
        |          "identity"
        |      ),
     1..|      ["identity"] = pick_accepted_encodings(
        |          [{"gzip", 0.0}],
        |          ["gzip", "identity"],
        |          "identity"
        |      ),
     1..|      ["gzip", "identity"] = pick_accepted_encodings(
        |          [{"gzip", 1.0}, {"deflate", 1.0}],
        |          ["gzip", "identity"],
        |          "identity"
        |      ),
     1..|      ["gzip", "identity"] = pick_accepted_encodings(
        |          [{"gzip", 0.5}, {"deflate", 1.0}],
        |          ["gzip", "identity"],
        |          "identity"
        |      ),
     1..|      ["identity"] = pick_accepted_encodings(
        |          [{"gzip", 0.0}, {"deflate", 0.0}],
        |          ["gzip", "identity"],
        |          "identity"
        |      ),
     1..|      ["gzip"] = pick_accepted_encodings(
        |          [{"gzip", 1.0}, {"deflate", 1.0}, {"identity", 0.0}],
        |          ["gzip", "identity"],
        |          "identity"
        |      ),
     1..|      ["gzip", "deflate", "identity"] = pick_accepted_encodings(
        |          [{"gzip", 1.0}, {"deflate", 1.0}],
        |          ["gzip", "deflate", "identity"],
        |          "identity"
        |      ),
     1..|      ["gzip", "deflate"] = pick_accepted_encodings(
        |          [{"gzip", 1.0}, {"deflate", 1.0}, {"identity", 0.0}],
        |          ["gzip", "deflate", "identity"],
        |          "identity"
        |      ),
     1..|      ["deflate", "gzip", "identity"] = pick_accepted_encodings(
        |          [{"gzip", 0.2}, {"deflate", 1.0}],
        |          ["gzip", "deflate", "identity"],
        |          "identity"
        |      ),
     1..|      ["deflate", "deflate", "gzip", "identity"] = pick_accepted_encodings(
        |          [{"gzip", 0.2}, {"deflate", 1.0}, {"deflate", 1.0}],
        |          ["gzip", "deflate", "identity"],
        |          "identity"
        |      ),
     1..|      ["deflate", "gzip", "gzip", "identity"] = pick_accepted_encodings(
        |          [{"gzip", 0.2}, {"deflate", 1.0}, {"gzip", 1.0}],
        |          ["gzip", "deflate", "identity"],
        |          "identity"
        |      ),
     1..|      ["gzip", "deflate", "gzip", "identity"] = pick_accepted_encodings(
        |          [{"gzip", 0.2}, {"deflate", 0.9}, {"gzip", 1.0}],
        |          ["gzip", "deflate", "identity"],
        |          "identity"
        |      ),
     1..|      [] = pick_accepted_encodings(
        |          [{"*", 0.0}],
        |          ["gzip", "deflate", "identity"],
        |          "identity"
        |      ),
     1..|      ["gzip", "deflate", "identity"] = pick_accepted_encodings(
        |          [{"*", 1.0}],
        |          ["gzip", "deflate", "identity"],
        |          "identity"
        |      ),
     1..|      ["gzip", "deflate", "identity"] = pick_accepted_encodings(
        |          [{"*", 0.6}],
        |          ["gzip", "deflate", "identity"],
        |          "identity"
        |      ),
     1..|      ["gzip"] = pick_accepted_encodings(
        |          [{"gzip", 1.0}, {"*", 0.0}],
        |          ["gzip", "deflate", "identity"],
        |          "identity"
        |      ),
     1..|      ["gzip", "deflate"] = pick_accepted_encodings(
        |          [{"gzip", 1.0}, {"deflate", 0.6}, {"*", 0.0}],
        |          ["gzip", "deflate", "identity"],
        |          "identity"
        |      ),
     1..|      ["deflate", "gzip"] = pick_accepted_encodings(
        |          [{"gzip", 0.5}, {"deflate", 1.0}, {"*", 0.0}],
        |          ["gzip", "deflate", "identity"],
        |          "identity"
        |      ),
     1..|      ["gzip", "identity"] = pick_accepted_encodings(
        |          [{"deflate", 0.0}, {"*", 1.0}],
        |          ["gzip", "deflate", "identity"],
        |          "identity"
        |      ),
     1..|      ["gzip", "identity"] = pick_accepted_encodings(
        |          [{"*", 1.0}, {"deflate", 0.0}],
        |          ["gzip", "deflate", "identity"],
        |          "identity"
        |      ),
     1..|      ok.
        |  
        |  -endif.
</pre>
</body>
</html>
