<html>
<head><title>.eunit/mochiweb_multipart.COVER.html</title></head><body bgcolor=white text=black>
<pre>
File generated from /Users/seb/Documents/part2project/app/deps/mochiweb/.eunit/mochiweb_multipart.erl by COVER 2010-10-28 at 14:19:50

****************************************************************************

        |  %% @author Bob Ippolito &lt;bob@mochimedia.com&gt;
        |  %% @copyright 2007 Mochi Media, Inc.
        |  
        |  %% @doc Utilities for parsing multipart/form-data.
        |  
        |  -module(mochiweb_multipart).
        |  -author('bob@mochimedia.com').
        |  
        |  -export([parse_form/1, parse_form/2]).
        |  -export([parse_multipart_request/2]).
        |  -export([parts_to_body/3, parts_to_multipart_body/4]).
        |  -export([default_file_handler/2]).
        |  
        |  -define(CHUNKSIZE, 4096).
        |  
        |  -record(mp, {state, boundary, length, buffer, callback, req}).
        |  
        |  %% TODO: DOCUMENT THIS MODULE.
        |  %% @type key() = atom() | string() | binary().
        |  %% @type value() = atom() | iolist() | integer().
        |  %% @type header() = {key(), value()}.
        |  %% @type bodypart() = {Start::integer(), End::integer(), Body::iolist()}.
        |  %% @type formfile() = {Name::string(), ContentType::string(), Content::binary()}.
        |  %% @type request().
        |  %% @type file_handler() = (Filename::string(), ContentType::string()) -&gt; file_handler_callback().
        |  %% @type file_handler_callback() = (binary() | eof) -&gt; file_handler_callback() | term().
        |  
        |  %% @spec parts_to_body([bodypart()], ContentType::string(),
        |  %%                     Size::integer()) -&gt; {[header()], iolist()}
        |  %% @doc Return {[header()], iolist()} representing the body for the given
        |  %%      parts, may be a single part or multipart.
        |  parts_to_body([{Start, End, Body}], ContentType, Size) -&gt;
     1..|      HeaderList = [{"Content-Type", ContentType},
        |                    {"Content-Range",
        |                     ["bytes ",
        |                      mochiweb_util:make_io(Start), "-", mochiweb_util:make_io(End),
        |                      "/", mochiweb_util:make_io(Size)]}],
     1..|      {HeaderList, Body};
        |  parts_to_body(BodyList, ContentType, Size) when is_list(BodyList) -&gt;
     1..|      parts_to_multipart_body(BodyList, ContentType, Size,
        |                              mochihex:to_hex(crypto:rand_bytes(8))).
        |  
        |  %% @spec parts_to_multipart_body([bodypart()], ContentType::string(),
        |  %%                               Size::integer(), Boundary::string()) -&gt;
        |  %%           {[header()], iolist()}
        |  %% @doc Return {[header()], iolist()} representing the body for the given
        |  %%      parts, always a multipart response.
        |  parts_to_multipart_body(BodyList, ContentType, Size, Boundary) -&gt;
     2..|      HeaderList = [{"Content-Type",
        |                     ["multipart/byteranges; ",
        |                      "boundary=", Boundary]}],
     2..|      MultiPartBody = multipart_body(BodyList, ContentType, Boundary, Size),
        |  
     2..|      {HeaderList, MultiPartBody}.
        |  
        |  %% @spec multipart_body([bodypart()], ContentType::string(),
        |  %%                      Boundary::string(), Size::integer()) -&gt; iolist()
        |  %% @doc Return the representation of a multipart body for the given [bodypart()].
        |  multipart_body([], _ContentType, Boundary, _Size) -&gt;
     5..|      ["--", Boundary, "--\r\n"];
        |  multipart_body([{Start, End, Body} | BodyList], ContentType, Boundary, Size) -&gt;
     8..|      ["--", Boundary, "\r\n",
        |       "Content-Type: ", ContentType, "\r\n",
        |       "Content-Range: ",
        |           "bytes ", mochiweb_util:make_io(Start), "-", mochiweb_util:make_io(End),
        |               "/", mochiweb_util:make_io(Size), "\r\n\r\n",
        |       Body, "\r\n"
        |       | multipart_body(BodyList, ContentType, Boundary, Size)].
        |  
        |  %% @spec parse_form(request()) -&gt; [{string(), string() | formfile()}]
        |  %% @doc Parse a multipart form from the given request using the in-memory
        |  %%      default_file_handler/2.
        |  parse_form(Req) -&gt;
     2..|      parse_form(Req, fun default_file_handler/2).
        |  
        |  %% @spec parse_form(request(), F::file_handler()) -&gt; [{string(), string() | term()}]
        |  %% @doc Parse a multipart form from the given request using the given file_handler().
        |  parse_form(Req, FileHandler) -&gt;
     2..|      Callback = fun (Next) -&gt; parse_form_outer(Next, FileHandler, []) end,
     2..|      {_, _, Res} = parse_multipart_request(Req, Callback),
     2..|      Res.
        |  
        |  parse_form_outer(eof, _, Acc) -&gt;
     2..|      lists:reverse(Acc);
        |  parse_form_outer({headers, H}, FileHandler, State) -&gt;
     4..|      {"form-data", H1} = proplists:get_value("content-disposition", H),
     4..|      Name = proplists:get_value("name", H1),
     4..|      Filename = proplists:get_value("filename", H1),
     4..|      case Filename of
        |          undefined -&gt;
     2..|              fun (Next) -&gt;
     2..|                      parse_form_value(Next, {Name, []}, FileHandler, State)
        |              end;
        |          _ -&gt;
     2..|              ContentType = proplists:get_value("content-type", H),
     2..|              Handler = FileHandler(Filename, ContentType),
     2..|              fun (Next) -&gt;
     2..|                      parse_form_file(Next, {Name, Handler}, FileHandler, State)
        |              end
        |      end.
        |  
        |  parse_form_value(body_end, {Name, Acc}, FileHandler, State) -&gt;
     2..|      Value = binary_to_list(iolist_to_binary(lists:reverse(Acc))),
     2..|      State1 = [{Name, Value} | State],
     2..|      fun (Next) -&gt; parse_form_outer(Next, FileHandler, State1) end;
        |  parse_form_value({body, Data}, {Name, Acc}, FileHandler, State) -&gt;
     2..|      Acc1 = [Data | Acc],
     2..|      fun (Next) -&gt; parse_form_value(Next, {Name, Acc1}, FileHandler, State) end.
        |  
        |  parse_form_file(body_end, {Name, Handler}, FileHandler, State) -&gt;
     2..|      Value = Handler(eof),
     2..|      State1 = [{Name, Value} | State],
     2..|      fun (Next) -&gt; parse_form_outer(Next, FileHandler, State1) end;
        |  parse_form_file({body, Data}, {Name, Handler}, FileHandler, State) -&gt;
     2..|      H1 = Handler(Data),
     2..|      fun (Next) -&gt; parse_form_file(Next, {Name, H1}, FileHandler, State) end.
        |  
        |  default_file_handler(Filename, ContentType) -&gt;
     2..|      default_file_handler_1(Filename, ContentType, []).
        |  
        |  default_file_handler_1(Filename, ContentType, Acc) -&gt;
     4..|      fun(eof) -&gt;
     2..|              Value = iolist_to_binary(lists:reverse(Acc)),
     2..|              {Filename, ContentType, Value};
        |         (Next) -&gt;
     2..|              default_file_handler_1(Filename, ContentType, [Next | Acc])
        |      end.
        |  
        |  parse_multipart_request(Req, Callback) -&gt;
        |      %% TODO: Support chunked?
    16..|      Length = list_to_integer(Req:get_header_value("content-length")),
    16..|      Boundary = iolist_to_binary(
        |                   get_boundary(Req:get_header_value("content-type"))),
    16..|      Prefix = &lt;&lt;"\r\n--", Boundary/binary&gt;&gt;,
    16..|      BS = byte_size(Boundary),
    16..|      Chunk = read_chunk(Req, Length),
    16..|      Length1 = Length - byte_size(Chunk),
    16..|      &lt;&lt;"--", Boundary:BS/binary, "\r\n", Rest/binary&gt;&gt; = Chunk,
    16..|      feed_mp(headers, flash_multipart_hack(#mp{boundary=Prefix,
        |                                                length=Length1,
        |                                                buffer=Rest,
        |                                                callback=Callback,
        |                                                req=Req})).
        |  
        |  parse_headers(&lt;&lt;&gt;&gt;) -&gt;
     1..|      [];
        |  parse_headers(Binary) -&gt;
    40..|      parse_headers(Binary, []).
        |  
        |  parse_headers(Binary, Acc) -&gt;
    58..|      case find_in_binary(&lt;&lt;"\r\n"&gt;&gt;, Binary) of
        |          {exact, N} -&gt;
    18..|              &lt;&lt;Line:N/binary, "\r\n", Rest/binary&gt;&gt; = Binary,
    18..|              parse_headers(Rest, [split_header(Line) | Acc]);
        |          not_found -&gt;
    40..|              lists:reverse([split_header(Binary) | Acc])
        |      end.
        |  
        |  split_header(Line) -&gt;
    58..|      {Name, [$: | Value]} = lists:splitwith(fun (C) -&gt; C =/= $: end,
        |                                             binary_to_list(Line)),
    58..|      {string:to_lower(string:strip(Name)),
        |       mochiweb_util:parse_header(Value)}.
        |  
        |  read_chunk(Req, Length) when Length &gt; 0 -&gt;
    22..|      case Length of
        |          Length when Length &lt; ?CHUNKSIZE -&gt;
    16..|              Req:recv(Length);
        |          _ -&gt;
     6..|              Req:recv(?CHUNKSIZE)
        |      end.
        |  
        |  read_more(State=#mp{length=Length, buffer=Buffer, req=Req}) -&gt;
     6..|      Data = read_chunk(Req, Length),
     6..|      Buffer1 = &lt;&lt;Buffer/binary, Data/binary&gt;&gt;,
     6..|      flash_multipart_hack(State#mp{length=Length - byte_size(Data),
        |                                    buffer=Buffer1}).
        |  
        |  flash_multipart_hack(State=#mp{length=0, buffer=Buffer, boundary=Prefix}) -&gt;
        |      %% http://code.google.com/p/mochiweb/issues/detail?id=22
        |      %% Flash doesn't terminate multipart with \r\n properly so we fix it up here
    17..|      PrefixSize = size(Prefix),
    17..|      case size(Buffer) - (2 + PrefixSize) of
        |          Seek when Seek &gt;= 0 -&gt;
    16..|              case Buffer of
        |                  &lt;&lt;_:Seek/binary, Prefix:PrefixSize/binary, "--"&gt;&gt; -&gt;
     4..|                      Buffer1 = &lt;&lt;Buffer/binary, "\r\n"&gt;&gt;,
     4..|                      State#mp{buffer=Buffer1};
        |                  _ -&gt;
    12..|                      State
        |              end;
        |          _ -&gt;
     1..|              State
        |      end;
        |  flash_multipart_hack(State) -&gt;
     6..|      State.
        |  
        |  feed_mp(headers, State=#mp{buffer=Buffer, callback=Callback}) -&gt;
    40..|      {State1, P} = case find_in_binary(&lt;&lt;"\r\n\r\n"&gt;&gt;, Buffer) of
        |                        {exact, N} -&gt;
    38..|                            {State, N};
        |                        _ -&gt;
     2..|                            S1 = read_more(State),
        |                            %% Assume headers must be less than ?CHUNKSIZE
     2..|                            {exact, N} = find_in_binary(&lt;&lt;"\r\n\r\n"&gt;&gt;,
        |                                                        S1#mp.buffer),
     2..|                            {S1, N}
        |                    end,
    40..|      &lt;&lt;Headers:P/binary, "\r\n\r\n", Rest/binary&gt;&gt; = State1#mp.buffer,
    40..|      NextCallback = Callback({headers, parse_headers(Headers)}),
    40..|      feed_mp(body, State1#mp{buffer=Rest,
        |                              callback=NextCallback});
        |  feed_mp(body, State=#mp{boundary=Prefix, buffer=Buffer, callback=Callback}) -&gt;
    44..|      Boundary = find_boundary(Prefix, Buffer),
    44..|      case Boundary of
        |          {end_boundary, Start, Skip} -&gt;
    16..|              &lt;&lt;Data:Start/binary, _:Skip/binary, Rest/binary&gt;&gt; = Buffer,
    16..|              C1 = Callback({body, Data}),
    16..|              C2 = C1(body_end),
    16..|              {State#mp.length, Rest, C2(eof)};
        |          {next_boundary, Start, Skip} -&gt;
    24..|              &lt;&lt;Data:Start/binary, _:Skip/binary, Rest/binary&gt;&gt; = Buffer,
    24..|              C1 = Callback({body, Data}),
    24..|              feed_mp(headers, State#mp{callback=C1(body_end),
        |                                        buffer=Rest});
        |          {maybe, Start} -&gt;
     2..|              &lt;&lt;Data:Start/binary, Rest/binary&gt;&gt; = Buffer,
     2..|              feed_mp(body, read_more(State#mp{callback=Callback({body, Data}),
        |                                               buffer=Rest}));
        |          not_found -&gt;
     2..|              {Data, Rest} = {Buffer, &lt;&lt;&gt;&gt;},
     2..|              feed_mp(body, read_more(State#mp{callback=Callback({body, Data}),
        |                                               buffer=Rest}))
        |      end.
        |  
        |  get_boundary(ContentType) -&gt;
    28..|      {"multipart/form-data", Opts} = mochiweb_util:parse_header(ContentType),
    28..|      case proplists:get_value("boundary", Opts) of
        |          S when is_list(S) -&gt;
    28..|              S
        |      end.
        |  
        |  find_in_binary(B, Data) when size(B) &gt; 0 -&gt;
   161..|      case size(Data) - size(B) of
        |          Last when Last &lt; 0 -&gt;
     4..|              partial_find(B, Data, 0, size(Data));
        |          Last -&gt;
   157..|              find_in_binary(B, size(B), Data, 0, Last)
        |      end.
        |  
        |  find_in_binary(B, BS, D, N, Last) when N =&lt; Last-&gt;
 38604..|      case D of
        |          &lt;&lt;_:N/binary, B:BS/binary, _/binary&gt;&gt; -&gt;
   109..|              {exact, N};
        |          _ -&gt;
 38495..|              find_in_binary(B, BS, D, 1 + N, Last)
        |      end;
        |  find_in_binary(B, BS, D, N, Last) when N =:= 1 + Last -&gt;
    48..|      partial_find(B, D, N, BS - 1).
        |  
        |  partial_find(_B, _D, _N, 0) -&gt;
    46..|      not_found;
        |  partial_find(B, D, N, K) -&gt;
   171..|      &lt;&lt;B1:K/binary, _/binary&gt;&gt; = B,
   171..|      case D of
        |          &lt;&lt;_Skip:N/binary, B1:K/binary&gt;&gt; -&gt;
     6..|              {partial, N, K};
        |          _ -&gt;
   165..|              partial_find(B, D, 1 + N, K - 1)
        |      end.
        |  
        |  find_boundary(Prefix, Data) -&gt;
    53..|      case find_in_binary(Prefix, Data) of
        |          {exact, Skip} -&gt;
    47..|              PrefixSkip = Skip + size(Prefix),
    47..|              case Data of
        |                  &lt;&lt;_:PrefixSkip/binary, "\r\n", _/binary&gt;&gt; -&gt;
    26..|                      {next_boundary, Skip, size(Prefix) + 2};
        |                  &lt;&lt;_:PrefixSkip/binary, "--\r\n", _/binary&gt;&gt; -&gt;
    18..|                      {end_boundary, Skip, size(Prefix) + 4};
        |                  _ when size(Data) &lt; PrefixSkip + 4 -&gt;
        |                      %% Underflow
     2..|                      {maybe, Skip};
        |                  _ -&gt;
        |                      %% False positive
     1..|                      not_found
        |              end;
        |          {partial, Skip, Length} when (Skip + Length) =:= size(Data) -&gt;
        |              %% Underflow
     3..|              {maybe, Skip};
        |          _ -&gt;
     3..|              not_found
        |      end.
        |  
        |  %%
        |  %% Tests
        |  %%
        |  -include_lib("eunit/include/eunit.hrl").
        |  -ifdef(TEST).
        |  
        |  ssl_cert_opts() -&gt;
     8..|      EbinDir = filename:dirname(code:which(?MODULE)),
     8..|      CertDir = filename:join([EbinDir, "..", "support", "test-materials"]),
     8..|      CertFile = filename:join(CertDir, "test_ssl_cert.pem"),
     8..|      KeyFile = filename:join(CertDir, "test_ssl_key.pem"),
     8..|      [{certfile, CertFile}, {keyfile, KeyFile}].
        |  
        |  with_socket_server(Transport, ServerFun, ClientFun) -&gt;
    16..|      ServerOpts0 = [{ip, "127.0.0.1"}, {port, 0}, {loop, ServerFun}],
    16..|      ServerOpts = case Transport of
        |          plain -&gt;
     8..|              ServerOpts0;
        |          ssl -&gt;
     8..|              ServerOpts0 ++ [{ssl, true}, {ssl_opts, ssl_cert_opts()}]
        |      end,
    16..|      {ok, Server} = mochiweb_socket_server:start(ServerOpts),
    16..|      Port = mochiweb_socket_server:get(Server, port),
    16..|      ClientOpts = [binary, {active, false}],
    16..|      {ok, Client} = case Transport of
        |          plain -&gt;
     8..|              gen_tcp:connect("127.0.0.1", Port, ClientOpts);
        |          ssl -&gt;
     8..|              ClientOpts1 = [{ssl_imp, new} | ClientOpts],
     8..|              {ok, SslSocket} = ssl:connect("127.0.0.1", Port, ClientOpts1),
     8..|              {ok, {ssl, SslSocket}}
        |      end,
    16..|      Res = (catch ClientFun(Client)),
    16..|      mochiweb_socket_server:stop(Server),
    16..|      Res.
        |  
        |  fake_request(Socket, ContentType, Length) -&gt;
    16..|      mochiweb_request:new(Socket,
        |                           'POST',
        |                           "/multipart",
        |                           {1,1},
        |                           mochiweb_headers:make(
        |                             [{"content-type", ContentType},
        |                              {"content-length", Length}])).
        |  
        |  test_callback({body, &lt;&lt;&gt;&gt;}, Rest=[body_end | _]) -&gt;
        |      %% When expecting the body_end we might get an empty binary
     2..|      fun (Next) -&gt; test_callback(Next, Rest) end;
        |  test_callback({body, Got}, [{body, Expect} | Rest]) when Got =/= Expect -&gt;
        |      %% Partial response
     2..|      GotSize = size(Got),
     2..|      &lt;&lt;Got:GotSize/binary, Expect1/binary&gt;&gt; = Expect,
     2..|      fun (Next) -&gt; test_callback(Next, [{body, Expect1} | Rest]) end;
        |  test_callback(Got, [Expect | Rest]) -&gt;
   122..|      ?assertEqual(Got, Expect),
   122..|      case Rest of
        |          [] -&gt;
    14..|              ok;
        |          _ -&gt;
   108..|              fun (Next) -&gt; test_callback(Next, Rest) end
        |      end.
        |  
        |  parse3_http_test() -&gt;
     1..|      parse3(plain).
        |  
        |  parse3_https_test() -&gt;
     1..|      parse3(ssl).
        |  
        |  parse3(Transport) -&gt;
     2..|      ContentType = "multipart/form-data; boundary=---------------------------7386909285754635891697677882",
     2..|      BinContent = &lt;&lt;"-----------------------------7386909285754635891697677882\r\nContent-Disposition: form-data; name=\"hidden\"\r\n\r\nmultipart message\r\n-----------------------------7386909285754635891697677882\r\nContent-Disposition: form-data; name=\"file\"; filename=\"test_file.txt\"\r\nContent-Type: text/plain\r\n\r\nWoo multiline text file\n\nLa la la\r\n-----------------------------7386909285754635891697677882--\r\n"&gt;&gt;,
     2..|      Expect = [{headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "hidden"}]}}]},
        |                {body, &lt;&lt;"multipart message"&gt;&gt;},
        |                body_end,
        |                {headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "file"}, {"filename", "test_file.txt"}]}},
        |                  {"content-type", {"text/plain", []}}]},
        |                {body, &lt;&lt;"Woo multiline text file\n\nLa la la"&gt;&gt;},
        |                body_end,
        |                eof],
     2..|      TestCallback = fun (Next) -&gt; test_callback(Next, Expect) end,
     2..|      ServerFun = fun (Socket) -&gt;
     2..|                          ok = mochiweb_socket:send(Socket, BinContent),
     2..|                          exit(normal)
        |                  end,
     2..|      ClientFun = fun (Socket) -&gt;
     2..|                          Req = fake_request(Socket, ContentType,
        |                                             byte_size(BinContent)),
     2..|                          Res = parse_multipart_request(Req, TestCallback),
     2..|                          {0, &lt;&lt;&gt;&gt;, ok} = Res,
     2..|                          ok
        |                  end,
     2..|      ok = with_socket_server(Transport, ServerFun, ClientFun),
     2..|      ok.
        |  
        |  parse2_http_test() -&gt;
     1..|      parse2(plain).
        |  
        |  parse2_https_test() -&gt;
     1..|      parse2(ssl).
        |  
        |  parse2(Transport) -&gt;
     2..|      ContentType = "multipart/form-data; boundary=---------------------------6072231407570234361599764024",
     2..|      BinContent = &lt;&lt;"-----------------------------6072231407570234361599764024\r\nContent-Disposition: form-data; name=\"hidden\"\r\n\r\nmultipart message\r\n-----------------------------6072231407570234361599764024\r\nContent-Disposition: form-data; name=\"file\"; filename=\"\"\r\nContent-Type: application/octet-stream\r\n\r\n\r\n-----------------------------6072231407570234361599764024--\r\n"&gt;&gt;,
     2..|      Expect = [{headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "hidden"}]}}]},
        |                {body, &lt;&lt;"multipart message"&gt;&gt;},
        |                body_end,
        |                {headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "file"}, {"filename", ""}]}},
        |                  {"content-type", {"application/octet-stream", []}}]},
        |                {body, &lt;&lt;&gt;&gt;},
        |                body_end,
        |                eof],
     2..|      TestCallback = fun (Next) -&gt; test_callback(Next, Expect) end,
     2..|      ServerFun = fun (Socket) -&gt;
     2..|                          ok = mochiweb_socket:send(Socket, BinContent),
     2..|                          exit(normal)
        |                  end,
     2..|      ClientFun = fun (Socket) -&gt;
     2..|                          Req = fake_request(Socket, ContentType,
        |                                             byte_size(BinContent)),
     2..|                          Res = parse_multipart_request(Req, TestCallback),
     2..|                          {0, &lt;&lt;&gt;&gt;, ok} = Res,
     2..|                          ok
        |                  end,
     2..|      ok = with_socket_server(Transport, ServerFun, ClientFun),
     2..|      ok.
        |  
        |  parse_form_http_test() -&gt;
     1..|      do_parse_form(plain).
        |  
        |  parse_form_https_test() -&gt;
     1..|      do_parse_form(ssl).
        |  
        |  do_parse_form(Transport) -&gt;
     2..|      ContentType = "multipart/form-data; boundary=AaB03x",
     2..|      "AaB03x" = get_boundary(ContentType),
     2..|      Content = mochiweb_util:join(
        |                  ["--AaB03x",
        |                   "Content-Disposition: form-data; name=\"submit-name\"",
        |                   "",
        |                   "Larry",
        |                   "--AaB03x",
        |                   "Content-Disposition: form-data; name=\"files\";"
        |                   ++ "filename=\"file1.txt\"",
        |                   "Content-Type: text/plain",
        |                   "",
        |                   "... contents of file1.txt ...",
        |                   "--AaB03x--",
        |                   ""], "\r\n"),
     2..|      BinContent = iolist_to_binary(Content),
     2..|      ServerFun = fun (Socket) -&gt;
     2..|                          ok = mochiweb_socket:send(Socket, BinContent),
     2..|                          exit(normal)
        |                  end,
     2..|      ClientFun = fun (Socket) -&gt;
     2..|                          Req = fake_request(Socket, ContentType,
        |                                             byte_size(BinContent)),
     2..|                          Res = parse_form(Req),
        |                          [{"submit-name", "Larry"},
        |                           {"files", {"file1.txt", {"text/plain",[]},
        |                                      &lt;&lt;"... contents of file1.txt ..."&gt;&gt;}
     2..|                           }] = Res,
     2..|                          ok
        |                  end,
     2..|      ok = with_socket_server(Transport, ServerFun, ClientFun),
     2..|      ok.
        |  
        |  parse_http_test() -&gt;
     1..|      do_parse(plain).
        |  
        |  parse_https_test() -&gt;
     1..|      do_parse(ssl).
        |  
        |  do_parse(Transport) -&gt;
     2..|      ContentType = "multipart/form-data; boundary=AaB03x",
     2..|      "AaB03x" = get_boundary(ContentType),
     2..|      Content = mochiweb_util:join(
        |                  ["--AaB03x",
        |                   "Content-Disposition: form-data; name=\"submit-name\"",
        |                   "",
        |                   "Larry",
        |                   "--AaB03x",
        |                   "Content-Disposition: form-data; name=\"files\";"
        |                   ++ "filename=\"file1.txt\"",
        |                   "Content-Type: text/plain",
        |                   "",
        |                   "... contents of file1.txt ...",
        |                   "--AaB03x--",
        |                   ""], "\r\n"),
     2..|      BinContent = iolist_to_binary(Content),
     2..|      Expect = [{headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "submit-name"}]}}]},
        |                {body, &lt;&lt;"Larry"&gt;&gt;},
        |                body_end,
        |                {headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "files"}, {"filename", "file1.txt"}]}},
        |                   {"content-type", {"text/plain", []}}]},
        |                {body, &lt;&lt;"... contents of file1.txt ..."&gt;&gt;},
        |                body_end,
        |                eof],
     2..|      TestCallback = fun (Next) -&gt; test_callback(Next, Expect) end,
     2..|      ServerFun = fun (Socket) -&gt;
     2..|                          ok = mochiweb_socket:send(Socket, BinContent),
     2..|                          exit(normal)
        |                  end,
     2..|      ClientFun = fun (Socket) -&gt;
     2..|                          Req = fake_request(Socket, ContentType,
        |                                             byte_size(BinContent)),
     2..|                          Res = parse_multipart_request(Req, TestCallback),
     2..|                          {0, &lt;&lt;&gt;&gt;, ok} = Res,
     2..|                          ok
        |                  end,
     2..|      ok = with_socket_server(Transport, ServerFun, ClientFun),
     2..|      ok.
        |  
        |  parse_partial_body_boundary_http_test() -&gt;
     1..|     parse_partial_body_boundary(plain).
        |  
        |  parse_partial_body_boundary_https_test() -&gt;
     1..|     parse_partial_body_boundary(ssl).
        |  
        |  parse_partial_body_boundary(Transport) -&gt;
     2..|      Boundary = string:copies("$", 2048),
     2..|      ContentType = "multipart/form-data; boundary=" ++ Boundary,
     2..|      ?assertEqual(Boundary, get_boundary(ContentType)),
     2..|      Content = mochiweb_util:join(
        |                  ["--" ++ Boundary,
        |                   "Content-Disposition: form-data; name=\"submit-name\"",
        |                   "",
        |                   "Larry",
        |                   "--" ++ Boundary,
        |                   "Content-Disposition: form-data; name=\"files\";"
        |                   ++ "filename=\"file1.txt\"",
        |                   "Content-Type: text/plain",
        |                   "",
        |                   "... contents of file1.txt ...",
        |                   "--" ++ Boundary ++ "--",
        |                   ""], "\r\n"),
     2..|      BinContent = iolist_to_binary(Content),
     2..|      Expect = [{headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "submit-name"}]}}]},
        |                {body, &lt;&lt;"Larry"&gt;&gt;},
        |                body_end,
        |                {headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "files"}, {"filename", "file1.txt"}]}},
        |                  {"content-type", {"text/plain", []}}
        |                 ]},
        |                {body, &lt;&lt;"... contents of file1.txt ..."&gt;&gt;},
        |                body_end,
        |                eof],
     2..|      TestCallback = fun (Next) -&gt; test_callback(Next, Expect) end,
     2..|      ServerFun = fun (Socket) -&gt;
     2..|                          ok = mochiweb_socket:send(Socket, BinContent),
     2..|                          exit(normal)
        |                  end,
     2..|      ClientFun = fun (Socket) -&gt;
     2..|                          Req = fake_request(Socket, ContentType,
        |                                             byte_size(BinContent)),
     2..|                          Res = parse_multipart_request(Req, TestCallback),
     2..|                          {0, &lt;&lt;&gt;&gt;, ok} = Res,
     2..|                          ok
        |                  end,
     2..|      ok = with_socket_server(Transport, ServerFun, ClientFun),
     2..|      ok.
        |  
        |  parse_large_header_http_test() -&gt;
     1..|      parse_large_header(plain).
        |  
        |  parse_large_header_https_test() -&gt;
     1..|      parse_large_header(ssl).
        |  
        |  parse_large_header(Transport) -&gt;
     2..|      ContentType = "multipart/form-data; boundary=AaB03x",
     2..|      "AaB03x" = get_boundary(ContentType),
     2..|      Content = mochiweb_util:join(
        |                  ["--AaB03x",
        |                   "Content-Disposition: form-data; name=\"submit-name\"",
        |                   "",
        |                   "Larry",
        |                   "--AaB03x",
        |                   "Content-Disposition: form-data; name=\"files\";"
        |                   ++ "filename=\"file1.txt\"",
        |                   "Content-Type: text/plain",
        |                   "x-large-header: " ++ string:copies("%", 4096),
        |                   "",
        |                   "... contents of file1.txt ...",
        |                   "--AaB03x--",
        |                   ""], "\r\n"),
     2..|      BinContent = iolist_to_binary(Content),
     2..|      Expect = [{headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "submit-name"}]}}]},
        |                {body, &lt;&lt;"Larry"&gt;&gt;},
        |                body_end,
        |                {headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "files"}, {"filename", "file1.txt"}]}},
        |                  {"content-type", {"text/plain", []}},
        |                  {"x-large-header", {string:copies("%", 4096), []}}
        |                 ]},
        |                {body, &lt;&lt;"... contents of file1.txt ..."&gt;&gt;},
        |                body_end,
        |                eof],
     2..|      TestCallback = fun (Next) -&gt; test_callback(Next, Expect) end,
     2..|      ServerFun = fun (Socket) -&gt;
     2..|                          ok = mochiweb_socket:send(Socket, BinContent),
     2..|                          exit(normal)
        |                  end,
     2..|      ClientFun = fun (Socket) -&gt;
     2..|                          Req = fake_request(Socket, ContentType,
        |                                             byte_size(BinContent)),
     2..|                          Res = parse_multipart_request(Req, TestCallback),
     2..|                          {0, &lt;&lt;&gt;&gt;, ok} = Res,
     2..|                          ok
        |                  end,
     2..|      ok = with_socket_server(Transport, ServerFun, ClientFun),
     2..|      ok.
        |  
        |  find_boundary_test() -&gt;
     1..|      B = &lt;&lt;"\r\n--X"&gt;&gt;,
     1..|      {next_boundary, 0, 7} = find_boundary(B, &lt;&lt;"\r\n--X\r\nRest"&gt;&gt;),
     1..|      {next_boundary, 1, 7} = find_boundary(B, &lt;&lt;"!\r\n--X\r\nRest"&gt;&gt;),
     1..|      {end_boundary, 0, 9} = find_boundary(B, &lt;&lt;"\r\n--X--\r\nRest"&gt;&gt;),
     1..|      {end_boundary, 1, 9} = find_boundary(B, &lt;&lt;"!\r\n--X--\r\nRest"&gt;&gt;),
     1..|      not_found = find_boundary(B, &lt;&lt;"--X\r\nRest"&gt;&gt;),
     1..|      {maybe, 0} = find_boundary(B, &lt;&lt;"\r\n--X\r"&gt;&gt;),
     1..|      {maybe, 1} = find_boundary(B, &lt;&lt;"!\r\n--X\r"&gt;&gt;),
     1..|      P = &lt;&lt;"\r\n-----------------------------16037454351082272548568224146"&gt;&gt;,
     1..|      B0 = &lt;&lt;55,212,131,77,206,23,216,198,35,87,252,118,252,8,25,211,132,229,
        |            182,42,29,188,62,175,247,243,4,4,0,59, 13,10,45,45,45,45,45,45,45,
        |            45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,
        |            49,54,48,51,55,52,53,52,51,53,49&gt;&gt;,
     1..|      {maybe, 30} = find_boundary(P, B0),
     1..|      not_found = find_boundary(B, &lt;&lt;"\r\n--XJOPKE"&gt;&gt;),
     1..|      ok.
        |  
        |  find_in_binary_test() -&gt;
     1..|      {exact, 0} = find_in_binary(&lt;&lt;"foo"&gt;&gt;, &lt;&lt;"foobarbaz"&gt;&gt;),
     1..|      {exact, 1} = find_in_binary(&lt;&lt;"oo"&gt;&gt;, &lt;&lt;"foobarbaz"&gt;&gt;),
     1..|      {exact, 8} = find_in_binary(&lt;&lt;"z"&gt;&gt;, &lt;&lt;"foobarbaz"&gt;&gt;),
     1..|      not_found = find_in_binary(&lt;&lt;"q"&gt;&gt;, &lt;&lt;"foobarbaz"&gt;&gt;),
     1..|      {partial, 7, 2} = find_in_binary(&lt;&lt;"azul"&gt;&gt;, &lt;&lt;"foobarbaz"&gt;&gt;),
     1..|      {exact, 0} = find_in_binary(&lt;&lt;"foobarbaz"&gt;&gt;, &lt;&lt;"foobarbaz"&gt;&gt;),
     1..|      {partial, 0, 3} = find_in_binary(&lt;&lt;"foobar"&gt;&gt;, &lt;&lt;"foo"&gt;&gt;),
     1..|      {partial, 1, 3} = find_in_binary(&lt;&lt;"foobar"&gt;&gt;, &lt;&lt;"afoo"&gt;&gt;),
     1..|      ok.
        |  
        |  flash_parse_http_test() -&gt;
     1..|      flash_parse(plain).
        |  
        |  flash_parse_https_test() -&gt;
     1..|      flash_parse(ssl).
        |  
        |  flash_parse(Transport) -&gt;
     2..|      ContentType = "multipart/form-data; boundary=----------ei4GI3GI3Ij5Ef1ae0KM7Ij5ei4Ij5",
     2..|      "----------ei4GI3GI3Ij5Ef1ae0KM7Ij5ei4Ij5" = get_boundary(ContentType),
     2..|      BinContent = &lt;&lt;"------------ei4GI3GI3Ij5Ef1ae0KM7Ij5ei4Ij5\r\nContent-Disposition: form-data; name=\"Filename\"\r\n\r\nhello.txt\r\n------------ei4GI3GI3Ij5Ef1ae0KM7Ij5ei4Ij5\r\nContent-Disposition: form-data; name=\"success_action_status\"\r\n\r\n201\r\n------------ei4GI3GI3Ij5Ef1ae0KM7Ij5ei4Ij5\r\nContent-Disposition: form-data; name=\"file\"; filename=\"hello.txt\"\r\nContent-Type: application/octet-stream\r\n\r\nhello\n\r\n------------ei4GI3GI3Ij5Ef1ae0KM7Ij5ei4Ij5\r\nContent-Disposition: form-data; name=\"Upload\"\r\n\r\nSubmit Query\r\n------------ei4GI3GI3Ij5Ef1ae0KM7Ij5ei4Ij5--"&gt;&gt;,
     2..|      Expect = [{headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "Filename"}]}}]},
        |                {body, &lt;&lt;"hello.txt"&gt;&gt;},
        |                body_end,
        |                {headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "success_action_status"}]}}]},
        |                {body, &lt;&lt;"201"&gt;&gt;},
        |                body_end,
        |                {headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "file"}, {"filename", "hello.txt"}]}},
        |                  {"content-type", {"application/octet-stream", []}}]},
        |                {body, &lt;&lt;"hello\n"&gt;&gt;},
        |                body_end,
        |                {headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "Upload"}]}}]},
        |                {body, &lt;&lt;"Submit Query"&gt;&gt;},
        |                body_end,
        |                eof],
     2..|      TestCallback = fun (Next) -&gt; test_callback(Next, Expect) end,
     2..|      ServerFun = fun (Socket) -&gt;
     2..|                          ok = mochiweb_socket:send(Socket, BinContent),
     2..|                          exit(normal)
        |                  end,
     2..|      ClientFun = fun (Socket) -&gt;
     2..|                          Req = fake_request(Socket, ContentType,
        |                                             byte_size(BinContent)),
     2..|                          Res = parse_multipart_request(Req, TestCallback),
     2..|                          {0, &lt;&lt;&gt;&gt;, ok} = Res,
     2..|                          ok
        |                  end,
     2..|      ok = with_socket_server(Transport, ServerFun, ClientFun),
     2..|      ok.
        |  
        |  flash_parse2_http_test() -&gt;
     1..|      flash_parse2(plain).
        |  
        |  flash_parse2_https_test() -&gt;
     1..|      flash_parse2(ssl).
        |  
        |  flash_parse2(Transport) -&gt;
     2..|      ContentType = "multipart/form-data; boundary=----------ei4GI3GI3Ij5Ef1ae0KM7Ij5ei4Ij5",
     2..|      "----------ei4GI3GI3Ij5Ef1ae0KM7Ij5ei4Ij5" = get_boundary(ContentType),
     2..|      Chunk = iolist_to_binary(string:copies("%", 4096)),
     2..|      BinContent = &lt;&lt;"------------ei4GI3GI3Ij5Ef1ae0KM7Ij5ei4Ij5\r\nContent-Disposition: form-data; name=\"Filename\"\r\n\r\nhello.txt\r\n------------ei4GI3GI3Ij5Ef1ae0KM7Ij5ei4Ij5\r\nContent-Disposition: form-data; name=\"success_action_status\"\r\n\r\n201\r\n------------ei4GI3GI3Ij5Ef1ae0KM7Ij5ei4Ij5\r\nContent-Disposition: form-data; name=\"file\"; filename=\"hello.txt\"\r\nContent-Type: application/octet-stream\r\n\r\n", Chunk/binary, "\r\n------------ei4GI3GI3Ij5Ef1ae0KM7Ij5ei4Ij5\r\nContent-Disposition: form-data; name=\"Upload\"\r\n\r\nSubmit Query\r\n------------ei4GI3GI3Ij5Ef1ae0KM7Ij5ei4Ij5--"&gt;&gt;,
     2..|      Expect = [{headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "Filename"}]}}]},
        |                {body, &lt;&lt;"hello.txt"&gt;&gt;},
        |                body_end,
        |                {headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "success_action_status"}]}}]},
        |                {body, &lt;&lt;"201"&gt;&gt;},
        |                body_end,
        |                {headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "file"}, {"filename", "hello.txt"}]}},
        |                  {"content-type", {"application/octet-stream", []}}]},
        |                {body, Chunk},
        |                body_end,
        |                {headers,
        |                 [{"content-disposition",
        |                   {"form-data", [{"name", "Upload"}]}}]},
        |                {body, &lt;&lt;"Submit Query"&gt;&gt;},
        |                body_end,
        |                eof],
     2..|      TestCallback = fun (Next) -&gt; test_callback(Next, Expect) end,
     2..|      ServerFun = fun (Socket) -&gt;
     2..|                          ok = mochiweb_socket:send(Socket, BinContent),
     2..|                          exit(normal)
        |                  end,
     2..|      ClientFun = fun (Socket) -&gt;
     2..|                          Req = fake_request(Socket, ContentType,
        |                                             byte_size(BinContent)),
     2..|                          Res = parse_multipart_request(Req, TestCallback),
     2..|                          {0, &lt;&lt;&gt;&gt;, ok} = Res,
     2..|                          ok
        |                  end,
     2..|      ok = with_socket_server(Transport, ServerFun, ClientFun),
     2..|      ok.
        |  
        |  parse_headers_test() -&gt;
     1..|      ?assertEqual([], parse_headers(&lt;&lt;&gt;&gt;)).
        |  
        |  flash_multipart_hack_test() -&gt;
     1..|      Buffer = &lt;&lt;"prefix-"&gt;&gt;,
     1..|      Prefix = &lt;&lt;"prefix"&gt;&gt;,
     1..|      State = #mp{length=0, buffer=Buffer, boundary=Prefix},
     1..|      ?assertEqual(State,
     1..|                   flash_multipart_hack(State)).
        |  
        |  parts_to_body_single_test() -&gt;
     1..|      {HL, B} = parts_to_body([{0, 5, &lt;&lt;"01234"&gt;&gt;}],
        |                              "text/plain",
        |                              10),
        |      [{"Content-Range", Range},
     1..|       {"Content-Type", Type}] = lists:sort(HL),
     1..|      ?assertEqual(
        |         &lt;&lt;"bytes 0-5/10"&gt;&gt;,
     1..|         iolist_to_binary(Range)),
     1..|      ?assertEqual(
        |         &lt;&lt;"text/plain"&gt;&gt;,
     1..|         iolist_to_binary(Type)),
     1..|      ?assertEqual(
        |         &lt;&lt;"01234"&gt;&gt;,
     1..|         iolist_to_binary(B)),
     1..|      ok.
        |  
        |  parts_to_body_multi_test() -&gt;
        |      {[{"Content-Type", Type}],
     1..|       _B} = parts_to_body([{0, 5, &lt;&lt;"01234"&gt;&gt;}, {5, 10, &lt;&lt;"56789"&gt;&gt;}],
        |                          "text/plain",
        |                          10),
     1..|      ?assertMatch(
     1..|         &lt;&lt;"multipart/byteranges; boundary=", _/binary&gt;&gt;,
        |         iolist_to_binary(Type)),
     1..|      ok.
        |  
        |  parts_to_multipart_body_test() -&gt;
     1..|      {[{"Content-Type", V}], B} = parts_to_multipart_body(
        |                                     [{0, 5, &lt;&lt;"01234"&gt;&gt;}, {5, 10, &lt;&lt;"56789"&gt;&gt;}],
        |                                     "text/plain",
        |                                     10,
        |                                     "BOUNDARY"),
     1..|      MB = multipart_body(
        |             [{0, 5, &lt;&lt;"01234"&gt;&gt;}, {5, 10, &lt;&lt;"56789"&gt;&gt;}],
        |             "text/plain",
        |             "BOUNDARY",
        |             10),
     1..|      ?assertEqual(
        |         &lt;&lt;"multipart/byteranges; boundary=BOUNDARY"&gt;&gt;,
     1..|         iolist_to_binary(V)),
     1..|      ?assertEqual(
        |         iolist_to_binary(MB),
     1..|         iolist_to_binary(B)),
     1..|      ok.
        |  
        |  multipart_body_test() -&gt;
     1..|      ?assertEqual(
        |         &lt;&lt;"--BOUNDARY--\r\n"&gt;&gt;,
     1..|         iolist_to_binary(multipart_body([], "text/plain", "BOUNDARY", 0))),
     1..|      ?assertEqual(
        |         &lt;&lt;"--BOUNDARY\r\n"
        |           "Content-Type: text/plain\r\n"
        |           "Content-Range: bytes 0-5/10\r\n\r\n"
        |           "01234\r\n"
        |           "--BOUNDARY\r\n"
        |           "Content-Type: text/plain\r\n"
        |           "Content-Range: bytes 5-10/10\r\n\r\n"
        |           "56789\r\n"
        |           "--BOUNDARY--\r\n"&gt;&gt;,
        |         iolist_to_binary(multipart_body([{0, 5, &lt;&lt;"01234"&gt;&gt;}, {5, 10, &lt;&lt;"56789"&gt;&gt;}],
        |                                         "text/plain",
        |                                         "BOUNDARY",
     1..|                                         10))),
     1..|      ok.
        |  
        |  -endif.
</pre>
</body>
</html>
