<html>
<head><title>.eunit/mochiutf8.COVER.html</title></head><body bgcolor=white text=black>
<pre>
File generated from /Users/seb/Documents/part2project/app/deps/mochiweb/.eunit/mochiutf8.erl by COVER 2010-10-28 at 14:19:48

****************************************************************************

        |  %% @copyright 2010 Mochi Media, Inc.
        |  %% @author Bob Ippolito &lt;bob@mochimedia.com&gt;
        |  
        |  %% @doc Algorithm to convert any binary to a valid UTF-8 sequence by ignoring
        |  %%      invalid bytes.
        |  
        |  -module(mochiutf8).
        |  -export([valid_utf8_bytes/1, codepoint_to_bytes/1, bytes_to_codepoints/1]).
        |  -export([bytes_foldl/3, codepoint_foldl/3, read_codepoint/1, len/1]).
        |  
        |  %% External API
        |  
        |  -type unichar_low() :: 0..16#d7ff.
        |  -type unichar_high() :: 16#e000..16#10ffff.
        |  -type unichar() :: unichar_low() | unichar_high().
        |  
        |  -spec codepoint_to_bytes(unichar()) -&gt; binary().
        |  %% @doc Convert a unicode codepoint to UTF-8 bytes.
        |  codepoint_to_bytes(C) when (C &gt;= 16#00 andalso C =&lt; 16#7f) -&gt;
        |      %% U+0000 - U+007F - 7 bits
   257..|      &lt;&lt;C&gt;&gt;;
        |  codepoint_to_bytes(C) when (C &gt;= 16#080 andalso C =&lt; 16#07FF) -&gt;
        |      %% U+0080 - U+07FF - 11 bits
  1749..|      &lt;&lt;0:5, B1:5, B0:6&gt;&gt; = &lt;&lt;C:16&gt;&gt;,
  1749..|      &lt;&lt;2#110:3, B1:5,
        |        2#10:2, B0:6&gt;&gt;;
        |  codepoint_to_bytes(C) when (C &gt;= 16#0800 andalso C =&lt; 16#FFFF) andalso
        |                             (C &lt; 16#D800 orelse C &gt; 16#DFFF) -&gt;
        |      %% U+0800 - U+FFFF - 16 bits (excluding UTC-16 surrogate code points)
     1..|      &lt;&lt;B2:4, B1:6, B0:6&gt;&gt; = &lt;&lt;C:16&gt;&gt;,
     1..|      &lt;&lt;2#1110:4, B2:4,
        |        2#10:2, B1:6,
        |        2#10:2, B0:6&gt;&gt;;
        |  codepoint_to_bytes(C) when (C &gt;= 16#010000 andalso C =&lt; 16#10FFFF) -&gt;
        |      %% U+10000 - U+10FFFF - 21 bits
     1..|      &lt;&lt;0:3, B3:3, B2:6, B1:6, B0:6&gt;&gt; = &lt;&lt;C:24&gt;&gt;,
     1..|      &lt;&lt;2#11110:5, B3:3,
        |        2#10:2, B2:6,
        |        2#10:2, B1:6,
        |        2#10:2, B0:6&gt;&gt;.
        |  
        |  -spec codepoints_to_bytes([unichar()]) -&gt; binary().
        |  %% @doc Convert a list of codepoints to a UTF-8 binary.
        |  codepoints_to_bytes(L) -&gt;
     1..|      &lt;&lt;&lt;&lt;(codepoint_to_bytes(C))/binary&gt;&gt; || C &lt;- L&gt;&gt;.
        |  
        |  -spec read_codepoint(binary()) -&gt; {unichar(), binary(), binary()}.
        |  read_codepoint(Bin = &lt;&lt;2#0:1, C:7, Rest/binary&gt;&gt;) -&gt;
        |      %% U+0000 - U+007F - 7 bits
    40..|      &lt;&lt;B:1/binary, _/binary&gt;&gt; = Bin,
    40..|      {C, B, Rest};
        |  read_codepoint(Bin = &lt;&lt;2#110:3, B1:5,
        |                         2#10:2, B0:6,
        |                         Rest/binary&gt;&gt;) -&gt;
        |      %% U+0080 - U+07FF - 11 bits
     4..|      case &lt;&lt;B1:5, B0:6&gt;&gt; of
        |          &lt;&lt;C:11&gt;&gt; when C &gt;= 16#80 -&gt;
     4..|              &lt;&lt;B:2/binary, _/binary&gt;&gt; = Bin,
     4..|              {C, B, Rest}
        |      end;
        |  read_codepoint(Bin = &lt;&lt;2#1110:4, B2:4,
        |                         2#10:2, B1:6,
        |                         2#10:2, B0:6,
        |                         Rest/binary&gt;&gt;) -&gt;
        |      %% U+0800 - U+FFFF - 16 bits (excluding UTC-16 surrogate code points)
     8..|      case &lt;&lt;B2:4, B1:6, B0:6&gt;&gt; of
        |          &lt;&lt;C:16&gt;&gt; when (C &gt;= 16#0800 andalso C =&lt; 16#FFFF) andalso
        |                        (C &lt; 16#D800 orelse C &gt; 16#DFFF) -&gt;
     8..|              &lt;&lt;B:3/binary, _/binary&gt;&gt; = Bin,
     8..|              {C, B, Rest}
        |      end;
        |  read_codepoint(Bin = &lt;&lt;2#11110:5, B3:3,
        |                         2#10:2, B2:6,
        |                         2#10:2, B1:6,
        |                         2#10:2, B0:6,
        |                         Rest/binary&gt;&gt;) -&gt;
        |      %% U+10000 - U+10FFFF - 21 bits
     4..|      case &lt;&lt;B3:3, B2:6, B1:6, B0:6&gt;&gt; of
        |          &lt;&lt;C:21&gt;&gt; when (C &gt;= 16#010000 andalso C =&lt; 16#10FFFF) -&gt;
     4..|              &lt;&lt;B:4/binary, _/binary&gt;&gt; = Bin,
     4..|              {C, B, Rest}
        |      end.
        |  
        |  -spec codepoint_foldl(fun((unichar(), _) -&gt; _), _, binary()) -&gt; _.
        |  codepoint_foldl(F, Acc, &lt;&lt;&gt;&gt;) when is_function(F, 2) -&gt;
     3..|      Acc;
        |  codepoint_foldl(F, Acc, Bin) -&gt;
    17..|      {C, _, Rest} = read_codepoint(Bin),
    17..|      codepoint_foldl(F, F(C, Acc), Rest).
        |  
        |  -spec bytes_foldl(fun((binary(), _) -&gt; _), _, binary()) -&gt; _.
        |  bytes_foldl(F, Acc, &lt;&lt;&gt;&gt;) when is_function(F, 2) -&gt;
     2..|      Acc;
        |  bytes_foldl(F, Acc, Bin) -&gt;
    10..|      {_, B, Rest} = read_codepoint(Bin),
    10..|      bytes_foldl(F, F(B, Acc), Rest).
        |  
        |  -spec bytes_to_codepoints(binary()) -&gt; [unichar()].
        |  bytes_to_codepoints(B) -&gt;
     1..|      lists:reverse(codepoint_foldl(fun (C, Acc) -&gt; [C | Acc] end, [], B)).
        |  
        |  -spec len(binary()) -&gt; non_neg_integer().
        |  len(&lt;&lt;&gt;&gt;) -&gt;
     1..|      0;
        |  len(B) -&gt;
    29..|      {_, _, Rest} = read_codepoint(B),
    29..|      1 + len(Rest).
        |  
        |  -spec valid_utf8_bytes(B::binary()) -&gt; binary().
        |  %% @doc Return only the bytes in B that represent valid UTF-8. Uses
        |  %%      the following recursive algorithm: skip one byte if B does not
        |  %%      follow UTF-8 syntax (a 1-4 byte encoding of some number),
        |  %%      skip sequence of 2-4 bytes if it represents an overlong encoding
        |  %%      or bad code point (surrogate U+D800 - U+DFFF or &gt; U+10FFFF).
        |  valid_utf8_bytes(B) when is_binary(B) -&gt;
    10..|      binary_skip_bytes(B, invalid_utf8_indexes(B)).
        |  
        |  %% Internal API
        |  
        |  -spec binary_skip_bytes(binary(), [non_neg_integer()]) -&gt; binary().
        |  %% @doc Return B, but skipping the 0-based indexes in L.
        |  binary_skip_bytes(B, []) -&gt;
     4..|      B;
        |  binary_skip_bytes(B, L) -&gt;
    10..|      binary_skip_bytes(B, L, 0, []).
        |  
        |  %% @private
        |  -spec binary_skip_bytes(binary(), [non_neg_integer()], non_neg_integer(), iolist()) -&gt; binary().
        |  binary_skip_bytes(B, [], _N, Acc) -&gt;
    10..|      iolist_to_binary(lists:reverse([B | Acc]));
        |  binary_skip_bytes(&lt;&lt;_, RestB/binary&gt;&gt;, [N | RestL], N, Acc) -&gt;
    29..|      binary_skip_bytes(RestB, RestL, 1 + N, Acc);
        |  binary_skip_bytes(&lt;&lt;C, RestB/binary&gt;&gt;, L, N, Acc) -&gt;
   217..|      binary_skip_bytes(RestB, L, 1 + N, [C | Acc]).
        |  
        |  -spec invalid_utf8_indexes(binary()) -&gt; [non_neg_integer()].
        |  %% @doc Return the 0-based indexes in B that are not valid UTF-8.
        |  invalid_utf8_indexes(B) -&gt;
    13..|      invalid_utf8_indexes(B, 0, []).
        |  
        |  %% @private.
        |  -spec invalid_utf8_indexes(binary(), non_neg_integer(), [non_neg_integer()]) -&gt; [non_neg_integer()].
        |  invalid_utf8_indexes(&lt;&lt;C, Rest/binary&gt;&gt;, N, Acc) when C &lt; 16#80 -&gt;
        |      %% U+0000 - U+007F - 7 bits
   341..|      invalid_utf8_indexes(Rest, 1 + N, Acc);
        |  invalid_utf8_indexes(&lt;&lt;C1, C2, Rest/binary&gt;&gt;, N, Acc)
        |    when C1 band 16#E0 =:= 16#C0,
        |         C2 band 16#C0 =:= 16#80 -&gt;
        |      %% U+0080 - U+07FF - 11 bits
     3..|      case ((C1 band 16#1F) bsl 6) bor (C2 band 16#3F) of
        |          C when C &lt; 16#80 -&gt;
        |              %% Overlong encoding.
     2..|              invalid_utf8_indexes(Rest, 2 + N, [1 + N, N | Acc]);
        |          _ -&gt;
        |              %% Upper bound U+07FF does not need to be checked
     1..|              invalid_utf8_indexes(Rest, 2 + N, Acc)
        |      end;
        |  invalid_utf8_indexes(&lt;&lt;C1, C2, C3, Rest/binary&gt;&gt;, N, Acc)
        |    when C1 band 16#F0 =:= 16#E0,
        |         C2 band 16#C0 =:= 16#80,
        |         C3 band 16#C0 =:= 16#80 -&gt;
        |      %% U+0800 - U+FFFF - 16 bits
     4..|      case ((((C1 band 16#0F) bsl 6) bor (C2 band 16#3F)) bsl 6) bor
        |          (C3 band 16#3F) of
        |          C when (C &lt; 16#800) orelse (C &gt;= 16#D800 andalso C =&lt; 16#DFFF) -&gt;
        |              %% Overlong encoding or surrogate.
     2..|              invalid_utf8_indexes(Rest, 3 + N, [2 + N, 1 + N, N | Acc]);
        |          _ -&gt;
        |              %% Upper bound U+FFFF does not need to be checked
     2..|              invalid_utf8_indexes(Rest, 3 + N, Acc)
        |      end;
        |  invalid_utf8_indexes(&lt;&lt;C1, C2, C3, C4, Rest/binary&gt;&gt;, N, Acc)
        |    when C1 band 16#F8 =:= 16#F0,
        |         C2 band 16#C0 =:= 16#80,
        |         C3 band 16#C0 =:= 16#80,
        |         C4 band 16#C0 =:= 16#80 -&gt;
        |      %% U+10000 - U+10FFFF - 21 bits
     2..|      case ((((((C1 band 16#0F) bsl 6) bor (C2 band 16#3F)) bsl 6) bor
        |             (C3 band 16#3F)) bsl 6) bor (C4 band 16#3F) of
        |          C when (C &lt; 16#10000) orelse (C &gt; 16#10FFFF) -&gt;
        |              %% Overlong encoding or invalid code point.
     1..|              invalid_utf8_indexes(Rest, 4 + N, [3 + N, 2 + N, 1 + N, N | Acc]);
        |          _ -&gt;
     1..|              invalid_utf8_indexes(Rest, 4 + N, Acc)
        |      end;
        |  invalid_utf8_indexes(&lt;&lt;_, Rest/binary&gt;&gt;, N, Acc) -&gt;
        |      %% Invalid char
    16..|      invalid_utf8_indexes(Rest, 1 + N, [N | Acc]);
        |  invalid_utf8_indexes(&lt;&lt;&gt;&gt;, _N, Acc) -&gt;
    13..|      lists:reverse(Acc).
        |  
        |  %%
        |  %% Tests
        |  %%
        |  -include_lib("eunit/include/eunit.hrl").
        |  -ifdef(TEST).
        |  
        |  binary_skip_bytes_test() -&gt;
     1..|      ?assertEqual(&lt;&lt;"foo"&gt;&gt;,
     1..|                   binary_skip_bytes(&lt;&lt;"foo"&gt;&gt;, [])),
     1..|      ?assertEqual(&lt;&lt;"foobar"&gt;&gt;,
     1..|                   binary_skip_bytes(&lt;&lt;"foo bar"&gt;&gt;, [3])),
     1..|      ?assertEqual(&lt;&lt;"foo"&gt;&gt;,
     1..|                   binary_skip_bytes(&lt;&lt;"foo bar"&gt;&gt;, [3, 4, 5, 6])),
     1..|      ?assertEqual(&lt;&lt;"oo bar"&gt;&gt;,
     1..|                   binary_skip_bytes(&lt;&lt;"foo bar"&gt;&gt;, [0])),
     1..|      ok.
        |  
        |  invalid_utf8_indexes_test() -&gt;
     1..|      ?assertEqual(
        |         [],
     1..|         invalid_utf8_indexes(&lt;&lt;"unicode snowman for you: ", 226, 152, 131&gt;&gt;)),
     1..|      ?assertEqual(
        |         [0],
     1..|         invalid_utf8_indexes(&lt;&lt;128&gt;&gt;)),
     1..|      ?assertEqual(
        |         [57,59,60,64,66,67],
        |         invalid_utf8_indexes(&lt;&lt;"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; (",
     1..|                                167, 65, 170, 186, 73, 83, 80, 166, 87, 186, 217, 41, 41&gt;&gt;)),
     1..|      ok.
        |  
        |  codepoint_to_bytes_test() -&gt;
        |      %% U+0000 - U+007F - 7 bits
        |      %% U+0080 - U+07FF - 11 bits
        |      %% U+0800 - U+FFFF - 16 bits (excluding UTC-16 surrogate code points)
        |      %% U+10000 - U+10FFFF - 21 bits
     1..|      ?assertEqual(
        |         &lt;&lt;"a"&gt;&gt;,
     1..|         codepoint_to_bytes($a)),
     1..|      ?assertEqual(
        |         &lt;&lt;16#c2, 16#80&gt;&gt;,
     1..|         codepoint_to_bytes(16#80)),
     1..|      ?assertEqual(
        |         &lt;&lt;16#df, 16#bf&gt;&gt;,
     1..|         codepoint_to_bytes(16#07ff)),
     1..|      ?assertEqual(
        |         &lt;&lt;16#ef, 16#bf, 16#bf&gt;&gt;,
     1..|         codepoint_to_bytes(16#ffff)),
     1..|      ?assertEqual(
        |         &lt;&lt;16#f4, 16#8f, 16#bf, 16#bf&gt;&gt;,
     1..|         codepoint_to_bytes(16#10ffff)),
     1..|      ok.
        |  
        |  bytes_foldl_test() -&gt;
     1..|      ?assertEqual(
        |         &lt;&lt;"abc"&gt;&gt;,
     3..|         bytes_foldl(fun (B, Acc) -&gt; &lt;&lt;Acc/binary, B/binary&gt;&gt; end, &lt;&lt;&gt;&gt;, &lt;&lt;"abc"&gt;&gt;)),
     1..|      ?assertEqual(
        |         &lt;&lt;"abc", 226, 152, 131, 228, 184, 173, 194, 133, 244,143,191,191&gt;&gt;,
     7..|         bytes_foldl(fun (B, Acc) -&gt; &lt;&lt;Acc/binary, B/binary&gt;&gt; end, &lt;&lt;&gt;&gt;,
     1..|                     &lt;&lt;"abc", 226, 152, 131, 228, 184, 173, 194, 133, 244,143,191,191&gt;&gt;)),
     1..|      ok.
        |  
        |  bytes_to_codepoints_test() -&gt;
     1..|      ?assertEqual(
        |         "abc" ++ [16#2603, 16#4e2d, 16#85, 16#10ffff],
     1..|         bytes_to_codepoints(&lt;&lt;"abc", 226, 152, 131, 228, 184, 173, 194, 133, 244,143,191,191&gt;&gt;)),
     1..|      ok.
        |  
        |  codepoint_foldl_test() -&gt;
     1..|      ?assertEqual(
        |         "cba",
     3..|         codepoint_foldl(fun (C, Acc) -&gt; [C | Acc] end, [], &lt;&lt;"abc"&gt;&gt;)),
     1..|      ?assertEqual(
        |         [16#10ffff, 16#85, 16#4e2d, 16#2603 | "cba"],
     7..|         codepoint_foldl(fun (C, Acc) -&gt; [C | Acc] end, [],
     1..|                         &lt;&lt;"abc", 226, 152, 131, 228, 184, 173, 194, 133, 244,143,191,191&gt;&gt;)),
     1..|      ok.
        |  
        |  len_test() -&gt;
     1..|      ?assertEqual(
        |         29,
     1..|         len(&lt;&lt;"unicode snowman for you: ", 226, 152, 131, 228, 184, 173, 194, 133, 244, 143, 191, 191&gt;&gt;)),
     1..|      ok.
        |  
        |  codepoints_to_bytes_test() -&gt;
     1..|      ?assertEqual(
        |         iolist_to_binary(lists:map(fun codepoint_to_bytes/1, lists:seq(1, 1000))),
     1..|         codepoints_to_bytes(lists:seq(1, 1000))),
     1..|      ok.
        |  
        |  valid_utf8_bytes_test() -&gt;
     1..|      ?assertEqual(
        |         &lt;&lt;"invalid U+11ffff: "&gt;&gt;,
     1..|         valid_utf8_bytes(&lt;&lt;"invalid U+11ffff: ", 244, 159, 191, 191&gt;&gt;)),
     1..|      ?assertEqual(
        |         &lt;&lt;"U+10ffff: ", 244, 143, 191, 191&gt;&gt;,
     1..|         valid_utf8_bytes(&lt;&lt;"U+10ffff: ", 244, 143, 191, 191&gt;&gt;)),
     1..|      ?assertEqual(
        |         &lt;&lt;"overlong 2-byte encoding (a): "&gt;&gt;,
     1..|         valid_utf8_bytes(&lt;&lt;"overlong 2-byte encoding (a): ", 2#11000001, 2#10100001&gt;&gt;)),
     1..|      ?assertEqual(
        |         &lt;&lt;"overlong 2-byte encoding (!): "&gt;&gt;,
     1..|         valid_utf8_bytes(&lt;&lt;"overlong 2-byte encoding (!): ", 2#11000000, 2#10100001&gt;&gt;)),
     1..|      ?assertEqual(
        |         &lt;&lt;"mu: ", 194, 181&gt;&gt;,
     1..|         valid_utf8_bytes(&lt;&lt;"mu: ", 194, 181&gt;&gt;)),
     1..|      ?assertEqual(
        |         &lt;&lt;"bad coding bytes: "&gt;&gt;,
     1..|         valid_utf8_bytes(&lt;&lt;"bad coding bytes: ", 2#10011111, 2#10111111, 2#11111111&gt;&gt;)),
     1..|      ?assertEqual(
        |         &lt;&lt;"low surrogate (unpaired): "&gt;&gt;,
     1..|         valid_utf8_bytes(&lt;&lt;"low surrogate (unpaired): ", 237, 176, 128&gt;&gt;)),
     1..|      ?assertEqual(
        |         &lt;&lt;"high surrogate (unpaired): "&gt;&gt;,
     1..|         valid_utf8_bytes(&lt;&lt;"high surrogate (unpaired): ", 237, 191, 191&gt;&gt;)),
     1..|      ?assertEqual(
        |         &lt;&lt;"unicode snowman for you: ", 226, 152, 131&gt;&gt;,
     1..|         valid_utf8_bytes(&lt;&lt;"unicode snowman for you: ", 226, 152, 131&gt;&gt;)),
     1..|      ?assertEqual(
        |         &lt;&lt;"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; (AISPW))"&gt;&gt;,
        |         valid_utf8_bytes(&lt;&lt;"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; (",
     1..|                            167, 65, 170, 186, 73, 83, 80, 166, 87, 186, 217, 41, 41&gt;&gt;)),
     1..|      ok.
        |  
        |  -endif.
</pre>
</body>
</html>
