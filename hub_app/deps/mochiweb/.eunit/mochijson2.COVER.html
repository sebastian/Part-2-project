<html>
<head><title>.eunit/mochijson2.COVER.html</title></head><body bgcolor=white text=black>
<pre>
File generated from /Users/seb/Documents/part2project/app/deps/mochiweb/.eunit/mochijson2.erl by COVER 2010-10-28 at 14:19:48

****************************************************************************

        |  %% @author Bob Ippolito &lt;bob@mochimedia.com&gt;
        |  %% @copyright 2007 Mochi Media, Inc.
        |  
        |  %% @doc Yet another JSON (RFC 4627) library for Erlang. mochijson2 works
        |  %%      with binaries as strings, arrays as lists (without an {array, _})
        |  %%      wrapper and it only knows how to decode UTF-8 (and ASCII).
        |  
        |  -module(mochijson2).
        |  -author('bob@mochimedia.com').
        |  -export([encoder/1, encode/1]).
        |  -export([decoder/1, decode/1]).
        |  
        |  % This is a macro to placate syntax highlighters..
        |  -define(Q, $\").
        |  -define(ADV_COL(S, N), S#decoder{offset=N+S#decoder.offset,
        |                                   column=N+S#decoder.column}).
        |  -define(INC_COL(S), S#decoder{offset=1+S#decoder.offset,
        |                                column=1+S#decoder.column}).
        |  -define(INC_LINE(S), S#decoder{offset=1+S#decoder.offset,
        |                                 column=1,
        |                                 line=1+S#decoder.line}).
        |  -define(INC_CHAR(S, C),
        |          case C of
        |              $\n -&gt;
        |                  S#decoder{column=1,
        |                            line=1+S#decoder.line,
        |                            offset=1+S#decoder.offset};
        |              _ -&gt;
        |                  S#decoder{column=1+S#decoder.column,
        |                            offset=1+S#decoder.offset}
        |          end).
        |  -define(IS_WHITESPACE(C),
        |          (C =:= $\s orelse C =:= $\t orelse C =:= $\r orelse C =:= $\n)).
        |  
        |  %% @type iolist() = [char() | binary() | iolist()]
        |  %% @type iodata() = iolist() | binary()
        |  %% @type json_string() = atom | binary()
        |  %% @type json_number() = integer() | float()
        |  %% @type json_array() = [json_term()]
        |  %% @type json_object() = {struct, [{json_string(), json_term()}]}
        |  %% @type json_iolist() = {json, iolist()}
        |  %% @type json_term() = json_string() | json_number() | json_array() |
        |  %%                     json_object() | json_iolist()
        |  
        |  -record(encoder, {handler=null,
        |                    utf8=false}).
        |  
        |  -record(decoder, {object_hook=null,
        |                    offset=0,
        |                    line=1,
        |                    column=1,
        |                    state=null}).
        |  
        |  %% @spec encoder([encoder_option()]) -&gt; function()
        |  %% @doc Create an encoder/1 with the given options.
        |  %% @type encoder_option() = handler_option() | utf8_option()
        |  %% @type utf8_option() = boolean(). Emit unicode as utf8 (default - false)
        |  encoder(Options) -&gt;
     2..|      State = parse_encoder_options(Options, #encoder{}),
     2..|      fun (O) -&gt; json_encode(O, State) end.
        |  
        |  %% @spec encode(json_term()) -&gt; iolist()
        |  %% @doc Encode the given as JSON to an iolist.
        |  encode(Any) -&gt;
    56..|      json_encode(Any, #encoder{}).
        |  
        |  %% @spec decoder([decoder_option()]) -&gt; function()
        |  %% @doc Create a decoder/1 with the given options.
        |  decoder(Options) -&gt;
     2..|      State = parse_decoder_options(Options, #decoder{}),
     2..|      fun (O) -&gt; json_decode(O, State) end.
        |  
        |  %% @spec decode(iolist()) -&gt; json_term()
        |  %% @doc Decode the given iolist to Erlang terms.
        |  decode(S) -&gt;
    77..|      json_decode(S, #decoder{}).
        |  
        |  %% Internal API
        |  
        |  parse_encoder_options([], State) -&gt;
     2..|      State;
        |  parse_encoder_options([{handler, Handler} | Rest], State) -&gt;
     1..|      parse_encoder_options(Rest, State#encoder{handler=Handler});
        |  parse_encoder_options([{utf8, Switch} | Rest], State) -&gt;
     1..|      parse_encoder_options(Rest, State#encoder{utf8=Switch}).
        |  
        |  parse_decoder_options([], State) -&gt;
     2..|      State;
        |  parse_decoder_options([{object_hook, Hook} | Rest], State) -&gt;
     1..|      parse_decoder_options(Rest, State#decoder{object_hook=Hook}).
        |  
        |  json_encode(true, _State) -&gt;
     3..|      &lt;&lt;"true"&gt;&gt;;
        |  json_encode(false, _State) -&gt;
     1..|      &lt;&lt;"false"&gt;&gt;;
        |  json_encode(null, _State) -&gt;
     2..|      &lt;&lt;"null"&gt;&gt;;
        |  json_encode(I, _State) when is_integer(I) andalso I &gt;= -2147483648 andalso I =&lt; 2147483647 -&gt;
        |      %% Anything outside of 32-bit integers should be encoded as a float
    11..|      integer_to_list(I);
        |  json_encode(I, _State) when is_integer(I) -&gt;
     2..|      mochinum:digits(float(I));
        |  json_encode(F, _State) when is_float(F) -&gt;
     8..|      mochinum:digits(F);
        |  json_encode(S, State) when is_binary(S); is_atom(S) -&gt;
    29..|      json_encode_string(S, State);
        |  json_encode(Array, State) when is_list(Array) -&gt;
     9..|      json_encode_array(Array, State);
        |  json_encode({struct, Props}, State) when is_list(Props) -&gt;
    15..|      json_encode_proplist(Props, State);
        |  json_encode({json, IoList}, _State) -&gt;
     2..|      IoList;
        |  json_encode(Bad, #encoder{handler=null}) -&gt;
     1..|      exit({json_encode, {bad_term, Bad}});
        |  json_encode(Bad, State=#encoder{handler=Handler}) -&gt;
     1..|      json_encode(Handler(Bad), State).
        |  
        |  json_encode_array([], _State) -&gt;
     5..|      &lt;&lt;"[]"&gt;&gt;;
        |  json_encode_array(L, State) -&gt;
     4..|      F = fun (O, Acc) -&gt;
     8..|                  [$,, json_encode(O, State) | Acc]
        |          end,
     4..|      [$, | Acc1] = lists:foldl(F, "[", L),
     4..|      lists:reverse([$\] | Acc1]).
        |  
        |  json_encode_proplist([], _State) -&gt;
     1..|      &lt;&lt;"{}"&gt;&gt;;
        |  json_encode_proplist(Props, State) -&gt;
    14..|      F = fun ({K, V}, Acc) -&gt;
    17..|                  KS = json_encode_string(K, State),
    17..|                  VS = json_encode(V, State),
    17..|                  [$,, VS, $:, KS | Acc]
        |          end,
    14..|      [$, | Acc1] = lists:foldl(F, "{", Props),
    14..|      lists:reverse([$\} | Acc1]).
        |  
        |  json_encode_string(A, State) when is_atom(A) -&gt;
     5..|      L = atom_to_list(A),
     5..|      case json_string_is_safe(L) of
        |          true -&gt;
     3..|              [?Q, L, ?Q];
        |          false -&gt;
     2..|              json_encode_string_unicode(xmerl_ucs:from_utf8(L), State, [?Q])
        |      end;
        |  json_encode_string(B, State) when is_binary(B) -&gt;
    38..|      case json_bin_is_safe(B) of
        |          true -&gt;
    19..|              [?Q, B, ?Q];
        |          false -&gt;
    19..|              json_encode_string_unicode(xmerl_ucs:from_utf8(B), State, [?Q])
        |      end;
        |  json_encode_string(I, _State) when is_integer(I) -&gt;
     1..|      [?Q, integer_to_list(I), ?Q];
        |  json_encode_string(L, State) when is_list(L) -&gt;
     2..|      case json_string_is_safe(L) of
        |          true -&gt;
     1..|              [?Q, L, ?Q];
        |          false -&gt;
     1..|              json_encode_string_unicode(L, State, [?Q])
        |      end.
        |  
        |  json_string_is_safe([]) -&gt;
     4..|      true;
        |  json_string_is_safe([C | Rest]) -&gt;
    24..|      case C of
        |          ?Q -&gt;
     1..|              false;
        |          $\\ -&gt;
     1..|              false;
        |          $\b -&gt;
     1..|              false;
        |          $\f -&gt;
     1..|              false;
        |          $\n -&gt;
     1..|              false;
        |          $\r -&gt;
     1..|              false;
        |          $\t -&gt;
     1..|              false;
        |          C when C &gt;= 0, C &lt; $\s; C &gt;= 16#7f, C =&lt; 16#10FFFF -&gt;
     4..|              false;
        |          C when C &lt; 16#7f -&gt;
    12..|              json_string_is_safe(Rest);
        |          _ -&gt;
     1..|              false
        |      end.
        |  
        |  json_bin_is_safe(&lt;&lt;&gt;&gt;) -&gt;
    19..|      true;
        |  json_bin_is_safe(&lt;&lt;C, Rest/binary&gt;&gt;) -&gt;
    87..|      case C of
        |          ?Q -&gt;
     8..|              false;
        |          $\\ -&gt;
     2..|              false;
        |          $\b -&gt;
     2..|              false;
        |          $\f -&gt;
     2..|              false;
        |          $\n -&gt;
     3..|              false;
        |          $\r -&gt;
     2..|              false;
        |          $\t -&gt;
     2..|              false;
        |          C when C &gt;= 0, C &lt; $\s; C &gt;= 16#7f -&gt;
     7..|              false;
        |          C when C &lt; 16#7f -&gt;
    59..|              json_bin_is_safe(Rest)
        |      end.
        |  
        |  json_encode_string_unicode([], _State, Acc) -&gt;
    17..|      lists:reverse([$\" | Acc]);
        |  json_encode_string_unicode([C | Cs], State, Acc) -&gt;
    42..|      Acc1 = case C of
        |                 ?Q -&gt;
     4..|                     [?Q, $\\ | Acc];
        |                 %% Escaping solidus is only useful when trying to protect
        |                 %% against "&lt;/script&gt;" injection attacks which are only
        |                 %% possible when JSON is inserted into a HTML document
        |                 %% in-line. mochijson2 does not protect you from this, so
        |                 %% if you do insert directly into HTML then you need to
        |                 %% uncomment the following case or escape the output of encode.
        |                 %%
        |                 %% $/ -&gt;
        |                 %%    [$/, $\\ | Acc];
        |                 %%
        |                 $\\ -&gt;
     1..|                     [$\\, $\\ | Acc];
        |                 $\b -&gt;
     2..|                     [$b, $\\ | Acc];
        |                 $\f -&gt;
     2..|                     [$f, $\\ | Acc];
        |                 $\n -&gt;
     5..|                     [$n, $\\ | Acc];
        |                 $\r -&gt;
     2..|                     [$r, $\\ | Acc];
        |                 $\t -&gt;
     2..|                     [$t, $\\ | Acc];
        |                 C when C &gt;= 0, C &lt; $\s -&gt;
     3..|                     [unihex(C) | Acc];
        |                 C when C &gt;= 16#7f, C =&lt; 16#10FFFF, State#encoder.utf8 -&gt;
     4..|                     [xmerl_ucs:to_utf8(C) | Acc];
        |                 C when  C &gt;= 16#7f, C =&lt; 16#10FFFF, not State#encoder.utf8 -&gt;
     9..|                     [unihex(C) | Acc];
        |                 C when C &lt; 16#7f -&gt;
     7..|                     [C | Acc];
        |                 _ -&gt;
     1..|                     exit({json_encode, {bad_char, C}})
        |             end,
    41..|      json_encode_string_unicode(Cs, State, Acc1).
        |  
        |  hexdigit(C) when C &gt;= 0, C =&lt; 9 -&gt;
    53..|      C + $0;
        |  hexdigit(C) when C =&lt; 15 -&gt;
    15..|      C + $a - 10.
        |  
        |  unihex(C) when C &lt; 16#10000 -&gt;
    17..|      &lt;&lt;D3:4, D2:4, D1:4, D0:4&gt;&gt; = &lt;&lt;C:16&gt;&gt;,
    17..|      Digits = [hexdigit(D) || D &lt;- [D3, D2, D1, D0]],
    17..|      [$\\, $u | Digits];
        |  unihex(C) when C =&lt; 16#10FFFF -&gt;
     5..|      N = C - 16#10000,
     5..|      S1 = 16#d800 bor ((N bsr 10) band 16#3ff),
     5..|      S2 = 16#dc00 bor (N band 16#3ff),
     5..|      [unihex(S1), unihex(S2)].
        |  
        |  json_decode(L, S) when is_list(L) -&gt;
    66..|      json_decode(iolist_to_binary(L), S);
        |  json_decode(B, S) -&gt;
    79..|      {Res, S1} = decode1(B, S),
    74..|      {eof, _} = tokenize(B, S1#decoder{state=trim}),
    74..|      Res.
        |  
        |  decode1(B, S=#decoder{state=null}) -&gt;
   104..|      case tokenize(B, S#decoder{state=any}) of
        |          {{const, C}, S1} -&gt;
    65..|              {C, S1};
        |          {start_array, S1} -&gt;
    15..|              decode_array(B, S1);
        |          {start_object, S1} -&gt;
    19..|              decode_object(B, S1)
        |      end.
        |  
        |  make_object(V, #decoder{object_hook=null}) -&gt;
    20..|      V;
        |  make_object(V, #decoder{object_hook=Hook}) -&gt;
     1..|      Hook(V).
        |  
        |  decode_object(B, S) -&gt;
    21..|      decode_object(B, S#decoder{state=key}, []).
        |  
        |  decode_object(B, S=#decoder{state=key}, Acc) -&gt;
    27..|      case tokenize(B, S) of
        |          {end_object, S1} -&gt;
     2..|              V = make_object({struct, lists:reverse(Acc)}, S1),
     2..|              {V, S1#decoder{state=null}};
        |          {{const, K}, S1} -&gt;
    25..|              {colon, S2} = tokenize(B, S1),
    25..|              {V, S3} = decode1(B, S2#decoder{state=null}),
    25..|              decode_object(B, S3#decoder{state=comma}, [{K, V} | Acc])
        |      end;
        |  decode_object(B, S=#decoder{state=comma}, Acc) -&gt;
    25..|      case tokenize(B, S) of
        |          {end_object, S1} -&gt;
    19..|              V = make_object({struct, lists:reverse(Acc)}, S1),
    19..|              {V, S1#decoder{state=null}};
        |          {comma, S1} -&gt;
     6..|              decode_object(B, S1#decoder{state=key}, Acc)
        |      end.
        |  
        |  decode_array(B, S) -&gt;
    17..|      decode_array(B, S#decoder{state=any}, []).
        |  
        |  decode_array(B, S=#decoder{state=any}, Acc) -&gt;
    26..|      case tokenize(B, S) of
        |          {end_array, S1} -&gt;
     8..|              {lists:reverse(Acc), S1#decoder{state=null}};
        |          {start_array, S1} -&gt;
     2..|              {Array, S2} = decode_array(B, S1),
     2..|              decode_array(B, S2#decoder{state=comma}, [Array | Acc]);
        |          {start_object, S1} -&gt;
     2..|              {Array, S2} = decode_object(B, S1),
     2..|              decode_array(B, S2#decoder{state=comma}, [Array | Acc]);
        |          {{const, Const}, S1} -&gt;
    14..|              decode_array(B, S1#decoder{state=comma}, [Const | Acc])
        |      end;
        |  decode_array(B, S=#decoder{state=comma}, Acc) -&gt;
    18..|      case tokenize(B, S) of
        |          {end_array, S1} -&gt;
     9..|              {lists:reverse(Acc), S1#decoder{state=null}};
        |          {comma, S1} -&gt;
     9..|              decode_array(B, S1#decoder{state=any}, Acc)
        |      end.
        |  
        |  tokenize_string(B, S=#decoder{offset=O}) -&gt;
    67..|      case tokenize_string_fast(B, O) of
        |          {escape, O1} -&gt;
    17..|              Length = O1 - O,
    17..|              S1 = ?ADV_COL(S, Length),
    17..|              &lt;&lt;_:O/binary, Head:Length/binary, _/binary&gt;&gt; = B,
    17..|              tokenize_string(B, S1, lists:reverse(binary_to_list(Head)));
        |          O1 -&gt;
    45..|              Length = O1 - O,
    45..|              &lt;&lt;_:O/binary, String:Length/binary, ?Q, _/binary&gt;&gt; = B,
    45..|              {{const, String}, ?ADV_COL(S, Length + 1)}
        |      end.
        |  
        |  tokenize_string_fast(B, O) -&gt;
   214..|      case B of
        |          &lt;&lt;_:O/binary, ?Q, _/binary&gt;&gt; -&gt;
    45..|              O;
        |          &lt;&lt;_:O/binary, $\\, _/binary&gt;&gt; -&gt;
    17..|              {escape, O};
        |          &lt;&lt;_:O/binary, C1, _/binary&gt;&gt; when C1 &lt; 128 -&gt;
   144..|              tokenize_string_fast(B, 1 + O);
        |          &lt;&lt;_:O/binary, C1, C2, _/binary&gt;&gt; when C1 &gt;= 194, C1 =&lt; 223,
        |                  C2 &gt;= 128, C2 =&lt; 191 -&gt;
     1..|              tokenize_string_fast(B, 2 + O);
        |          &lt;&lt;_:O/binary, C1, C2, C3, _/binary&gt;&gt; when C1 &gt;= 224, C1 =&lt; 239,
        |                  C2 &gt;= 128, C2 =&lt; 191,
        |                  C3 &gt;= 128, C3 =&lt; 191 -&gt;
     1..|              tokenize_string_fast(B, 3 + O);
        |          &lt;&lt;_:O/binary, C1, C2, C3, C4, _/binary&gt;&gt; when C1 &gt;= 240, C1 =&lt; 244,
        |                  C2 &gt;= 128, C2 =&lt; 191,
        |                  C3 &gt;= 128, C3 =&lt; 191,
        |                  C4 &gt;= 128, C4 =&lt; 191 -&gt;
     1..|              tokenize_string_fast(B, 4 + O);
        |          _ -&gt;
     5..|              throw(invalid_utf8)
        |      end.
        |  
        |  tokenize_string(B, S=#decoder{offset=O}, Acc) -&gt;
    58..|      case B of
        |          &lt;&lt;_:O/binary, ?Q, _/binary&gt;&gt; -&gt;
    17..|              {{const, iolist_to_binary(lists:reverse(Acc))}, ?INC_COL(S)};
        |          &lt;&lt;_:O/binary, "\\\"", _/binary&gt;&gt; -&gt;
     5..|              tokenize_string(B, ?ADV_COL(S, 2), [$\" | Acc]);
        |          &lt;&lt;_:O/binary, "\\\\", _/binary&gt;&gt; -&gt;
     1..|              tokenize_string(B, ?ADV_COL(S, 2), [$\\ | Acc]);
        |          &lt;&lt;_:O/binary, "\\/", _/binary&gt;&gt; -&gt;
     1..|              tokenize_string(B, ?ADV_COL(S, 2), [$/ | Acc]);
        |          &lt;&lt;_:O/binary, "\\b", _/binary&gt;&gt; -&gt;
     3..|              tokenize_string(B, ?ADV_COL(S, 2), [$\b | Acc]);
        |          &lt;&lt;_:O/binary, "\\f", _/binary&gt;&gt; -&gt;
     3..|              tokenize_string(B, ?ADV_COL(S, 2), [$\f | Acc]);
        |          &lt;&lt;_:O/binary, "\\n", _/binary&gt;&gt; -&gt;
     9..|              tokenize_string(B, ?ADV_COL(S, 2), [$\n | Acc]);
        |          &lt;&lt;_:O/binary, "\\r", _/binary&gt;&gt; -&gt;
     3..|              tokenize_string(B, ?ADV_COL(S, 2), [$\r | Acc]);
        |          &lt;&lt;_:O/binary, "\\t", _/binary&gt;&gt; -&gt;
     3..|              tokenize_string(B, ?ADV_COL(S, 2), [$\t | Acc]);
        |          &lt;&lt;_:O/binary, "\\u", C3, C2, C1, C0, Rest/binary&gt;&gt; -&gt;
     5..|              C = erlang:list_to_integer([C3, C2, C1, C0], 16),
     5..|              if C &gt; 16#D7FF, C &lt; 16#DC00 -&gt;
        |                  %% coalesce UTF-16 surrogate pair
     3..|                  &lt;&lt;"\\u", D3, D2, D1, D0, _/binary&gt;&gt; = Rest,
     3..|                  D = erlang:list_to_integer([D3,D2,D1,D0], 16),
     3..|                  [CodePoint] = xmerl_ucs:from_utf16be(&lt;&lt;C:16/big-unsigned-integer,
        |                      D:16/big-unsigned-integer&gt;&gt;),
     3..|                  Acc1 = lists:reverse(xmerl_ucs:to_utf8(CodePoint), Acc),
     3..|                  tokenize_string(B, ?ADV_COL(S, 12), Acc1);
        |              true -&gt;
     2..|                  Acc1 = lists:reverse(xmerl_ucs:to_utf8(C), Acc),
     2..|                  tokenize_string(B, ?ADV_COL(S, 6), Acc1)
        |              end;
        |          &lt;&lt;_:O/binary, C, _/binary&gt;&gt; -&gt;
     8..|              tokenize_string(B, ?INC_CHAR(S, C), [C | Acc])
        |      end.
        |  
        |  tokenize_number(B, S) -&gt;
    33..|      case tokenize_number(B, sign, S, []) of
        |          {{int, Int}, S1} -&gt;
    16..|              {{const, list_to_integer(Int)}, S1};
        |          {{float, Float}, S1} -&gt;
    17..|              {{const, list_to_float(Float)}, S1}
        |      end.
        |  
        |  tokenize_number(B, sign, S=#decoder{offset=O}, []) -&gt;
    33..|      case B of
        |          &lt;&lt;_:O/binary, $-, _/binary&gt;&gt; -&gt;
     8..|              tokenize_number(B, int, ?INC_COL(S), [$-]);
        |          _ -&gt;
    25..|              tokenize_number(B, int, S, [])
        |      end;
        |  tokenize_number(B, int, S=#decoder{offset=O}, Acc) -&gt;
    33..|      case B of
        |          &lt;&lt;_:O/binary, $0, _/binary&gt;&gt; -&gt;
     1..|              tokenize_number(B, frac, ?INC_COL(S), [$0 | Acc]);
        |          &lt;&lt;_:O/binary, C, _/binary&gt;&gt; when C &gt;= $1 andalso C =&lt; $9 -&gt;
    32..|              tokenize_number(B, int1, ?INC_COL(S), [C | Acc])
        |      end;
        |  tokenize_number(B, int1, S=#decoder{offset=O}, Acc) -&gt;
    61..|      case B of
        |          &lt;&lt;_:O/binary, C, _/binary&gt;&gt; when C &gt;= $0 andalso C =&lt; $9 -&gt;
    29..|              tokenize_number(B, int1, ?INC_COL(S), [C | Acc]);
        |          _ -&gt;
    32..|              tokenize_number(B, frac, S, Acc)
        |      end;
        |  tokenize_number(B, frac, S=#decoder{offset=O}, Acc) -&gt;
    33..|      case B of
        |          &lt;&lt;_:O/binary, $., C, _/binary&gt;&gt; when C &gt;= $0, C =&lt; $9 -&gt;
    16..|              tokenize_number(B, frac1, ?ADV_COL(S, 2), [C, $. | Acc]);
        |          &lt;&lt;_:O/binary, E, _/binary&gt;&gt; when E =:= $e orelse E =:= $E -&gt;
     1..|              tokenize_number(B, esign, ?INC_COL(S), [$e, $0, $. | Acc]);
        |          _ -&gt;
    16..|              {{int, lists:reverse(Acc)}, S}
        |      end;
        |  tokenize_number(B, frac1, S=#decoder{offset=O}, Acc) -&gt;
    52..|      case B of
        |          &lt;&lt;_:O/binary, C, _/binary&gt;&gt; when C &gt;= $0 andalso C =&lt; $9 -&gt;
    36..|              tokenize_number(B, frac1, ?INC_COL(S), [C | Acc]);
        |          &lt;&lt;_:O/binary, E, _/binary&gt;&gt; when E =:= $e orelse E =:= $E -&gt;
     8..|              tokenize_number(B, esign, ?INC_COL(S), [$e | Acc]);
        |          _ -&gt;
     8..|              {{float, lists:reverse(Acc)}, S}
        |      end;
        |  tokenize_number(B, esign, S=#decoder{offset=O}, Acc) -&gt;
     9..|      case B of
        |          &lt;&lt;_:O/binary, C, _/binary&gt;&gt; when C =:= $- orelse C=:= $+ -&gt;
     8..|              tokenize_number(B, eint, ?INC_COL(S), [C | Acc]);
        |          _ -&gt;
     1..|              tokenize_number(B, eint, S, Acc)
        |      end;
        |  tokenize_number(B, eint, S=#decoder{offset=O}, Acc) -&gt;
     9..|      case B of
        |          &lt;&lt;_:O/binary, C, _/binary&gt;&gt; when C &gt;= $0 andalso C =&lt; $9 -&gt;
     9..|              tokenize_number(B, eint1, ?INC_COL(S), [C | Acc])
        |      end;
        |  tokenize_number(B, eint1, S=#decoder{offset=O}, Acc) -&gt;
    16..|      case B of
        |          &lt;&lt;_:O/binary, C, _/binary&gt;&gt; when C &gt;= $0 andalso C =&lt; $9 -&gt;
     7..|              tokenize_number(B, eint1, ?INC_COL(S), [C | Acc]);
        |          _ -&gt;
     9..|              {{float, lists:reverse(Acc)}, S}
        |      end.
        |  
        |  tokenize(B, S=#decoder{offset=O}) -&gt;
   301..|      case B of
        |          &lt;&lt;_:O/binary, C, _/binary&gt;&gt; when ?IS_WHITESPACE(C) -&gt;
     2..|              tokenize(B, ?INC_CHAR(S, C));
        |          &lt;&lt;_:O/binary, "{", _/binary&gt;&gt; -&gt;
    21..|              {start_object, ?INC_COL(S)};
        |          &lt;&lt;_:O/binary, "}", _/binary&gt;&gt; -&gt;
    21..|              {end_object, ?INC_COL(S)};
        |          &lt;&lt;_:O/binary, "[", _/binary&gt;&gt; -&gt;
    17..|              {start_array, ?INC_COL(S)};
        |          &lt;&lt;_:O/binary, "]", _/binary&gt;&gt; -&gt;
    17..|              {end_array, ?INC_COL(S)};
        |          &lt;&lt;_:O/binary, ",", _/binary&gt;&gt; -&gt;
    15..|              {comma, ?INC_COL(S)};
        |          &lt;&lt;_:O/binary, ":", _/binary&gt;&gt; -&gt;
    25..|              {colon, ?INC_COL(S)};
        |          &lt;&lt;_:O/binary, "null", _/binary&gt;&gt; -&gt;
     3..|              {{const, null}, ?ADV_COL(S, 4)};
        |          &lt;&lt;_:O/binary, "true", _/binary&gt;&gt; -&gt;
     5..|              {{const, true}, ?ADV_COL(S, 4)};
        |          &lt;&lt;_:O/binary, "false", _/binary&gt;&gt; -&gt;
     1..|              {{const, false}, ?ADV_COL(S, 5)};
        |          &lt;&lt;_:O/binary, "\"", _/binary&gt;&gt; -&gt;
    67..|              tokenize_string(B, ?INC_COL(S));
        |          &lt;&lt;_:O/binary, C, _/binary&gt;&gt; when (C &gt;= $0 andalso C =&lt; $9)
        |                                           orelse C =:= $- -&gt;
    33..|              tokenize_number(B, S);
        |          &lt;&lt;_:O/binary&gt;&gt; -&gt;
    74..|              trim = S#decoder.state,
    74..|              {eof, S}
        |      end.
        |  %%
        |  %% Tests
        |  %%
        |  -include_lib("eunit/include/eunit.hrl").
        |  -ifdef(TEST).
        |  
        |  
        |  %% testing constructs borrowed from the Yaws JSON implementation.
        |  
        |  %% Create an object from a list of Key/Value pairs.
        |  
        |  obj_new() -&gt;
     1..|      {struct, []}.
        |  
        |  is_obj({struct, Props}) -&gt;
     8..|      F = fun ({K, _}) when is_binary(K) -&gt; true end,
     8..|      lists:all(F, Props).
        |  
        |  obj_from_list(Props) -&gt;
     8..|      Obj = {struct, Props},
     8..|      ?assert(is_obj(Obj)),
     8..|      Obj.
        |  
        |  %% Test for equivalence of Erlang terms.
        |  %% Due to arbitrary order of construction, equivalent objects might
        |  %% compare unequal as erlang terms, so we need to carefully recurse
        |  %% through aggregates (tuples and objects).
        |  
        |  equiv({struct, Props1}, {struct, Props2}) -&gt;
    18..|      equiv_object(Props1, Props2);
        |  equiv(L1, L2) when is_list(L1), is_list(L2) -&gt;
    16..|      equiv_list(L1, L2);
    28..|  equiv(N1, N2) when is_number(N1), is_number(N2) -&gt; N1 == N2;
    42..|  equiv(B1, B2) when is_binary(B1), is_binary(B2) -&gt; B1 == B2;
     6..|  equiv(A, A) when A =:= true orelse A =:= false orelse A =:= null -&gt; true.
        |  
        |  %% Object representation and traversal order is unknown.
        |  %% Use the sledgehammer and sort property lists.
        |  
        |  equiv_object(Props1, Props2) -&gt;
    18..|      L1 = lists:keysort(1, Props1),
    18..|      L2 = lists:keysort(1, Props2),
    18..|      Pairs = lists:zip(L1, L2),
    18..|      true = lists:all(fun({{K1, V1}, {K2, V2}}) -&gt;
    22..|                               equiv(K1, K2) and equiv(V1, V2)
        |                       end, Pairs).
        |  
        |  %% Recursively compare tuple elements for equivalence.
        |  
        |  equiv_list([], []) -&gt;
    16..|      true;
        |  equiv_list([V1 | L1], [V2 | L2]) -&gt;
    16..|      equiv(V1, V2) andalso equiv_list(L1, L2).
        |  
        |  decode_test() -&gt;
     1..|      [1199344435545.0, 1] = decode(&lt;&lt;"[1199344435545.0,1]"&gt;&gt;),
     1..|      &lt;&lt;16#F0,16#9D,16#9C,16#95&gt;&gt; = decode([34,"\\ud835","\\udf15",34]).
        |  
        |  e2j_vec_test() -&gt;
     1..|      test_one(e2j_test_vec(utf8), 1).
        |  
        |  test_one([], _N) -&gt;
        |      %% io:format("~p tests passed~n", [N-1]),
     1..|      ok;
        |  test_one([{E, J} | Rest], N) -&gt;
        |      %% io:format("[~p] ~p ~p~n", [N, E, J]),
    25..|      true = equiv(E, decode(J)),
    25..|      true = equiv(E, decode(encode(E))),
    25..|      test_one(Rest, 1+N).
        |  
        |  e2j_test_vec(utf8) -&gt;
     1..|      [
        |       {1, "1"},
        |       {3.1416, "3.14160"}, %% text representation may truncate, trail zeroes
        |       {-1, "-1"},
        |       {-3.1416, "-3.14160"},
        |       {12.0e10, "1.20000e+11"},
        |       {1.234E+10, "1.23400e+10"},
        |       {-1.234E-10, "-1.23400e-10"},
        |       {10.0, "1.0e+01"},
        |       {123.456, "1.23456E+2"},
        |       {10.0, "1e1"},
        |       {&lt;&lt;"foo"&gt;&gt;, "\"foo\""},
        |       {&lt;&lt;"foo", 5, "bar"&gt;&gt;, "\"foo\\u0005bar\""},
        |       {&lt;&lt;""&gt;&gt;, "\"\""},
        |       {&lt;&lt;"\n\n\n"&gt;&gt;, "\"\\n\\n\\n\""},
        |       {&lt;&lt;"\" \b\f\r\n\t\""&gt;&gt;, "\"\\\" \\b\\f\\r\\n\\t\\\"\""},
        |       {obj_new(), "{}"},
        |       {obj_from_list([{&lt;&lt;"foo"&gt;&gt;, &lt;&lt;"bar"&gt;&gt;}]), "{\"foo\":\"bar\"}"},
        |       {obj_from_list([{&lt;&lt;"foo"&gt;&gt;, &lt;&lt;"bar"&gt;&gt;}, {&lt;&lt;"baz"&gt;&gt;, 123}]),
        |        "{\"foo\":\"bar\",\"baz\":123}"},
        |       {[], "[]"},
        |       {[[]], "[[]]"},
        |       {[1, &lt;&lt;"foo"&gt;&gt;], "[1,\"foo\"]"},
        |  
        |       %% json array in a json object
        |       {obj_from_list([{&lt;&lt;"foo"&gt;&gt;, [123]}]),
        |        "{\"foo\":[123]}"},
        |  
        |       %% json object in a json object
        |       {obj_from_list([{&lt;&lt;"foo"&gt;&gt;, obj_from_list([{&lt;&lt;"bar"&gt;&gt;, true}])}]),
        |        "{\"foo\":{\"bar\":true}}"},
        |  
        |       %% fold evaluation order
        |       {obj_from_list([{&lt;&lt;"foo"&gt;&gt;, []},
        |                       {&lt;&lt;"bar"&gt;&gt;, obj_from_list([{&lt;&lt;"baz"&gt;&gt;, true}])},
        |                       {&lt;&lt;"alice"&gt;&gt;, &lt;&lt;"bob"&gt;&gt;}]),
        |        "{\"foo\":[],\"bar\":{\"baz\":true},\"alice\":\"bob\"}"},
        |  
        |       %% json object in a json array
        |       {[-123, &lt;&lt;"foo"&gt;&gt;, obj_from_list([{&lt;&lt;"bar"&gt;&gt;, []}]), null],
        |        "[-123,\"foo\",{\"bar\":[]},null]"}
        |      ].
        |  
        |  %% test utf8 encoding
        |  encoder_utf8_test() -&gt;
        |      %% safe conversion case (default)
     1..|      [34,"\\u0001","\\u0442","\\u0435","\\u0441","\\u0442",34] =
        |          encode(&lt;&lt;1,"\321\202\320\265\321\201\321\202"&gt;&gt;),
        |  
        |      %% raw utf8 output (optional)
     1..|      Enc = mochijson2:encoder([{utf8, true}]),
     1..|      [34,"\\u0001",[209,130],[208,181],[209,129],[209,130],34] =
        |          Enc(&lt;&lt;1,"\321\202\320\265\321\201\321\202"&gt;&gt;).
        |  
        |  input_validation_test() -&gt;
     1..|      Good = [
        |          {16#00A3, &lt;&lt;?Q, 16#C2, 16#A3, ?Q&gt;&gt;}, %% pound
        |          {16#20AC, &lt;&lt;?Q, 16#E2, 16#82, 16#AC, ?Q&gt;&gt;}, %% euro
        |          {16#10196, &lt;&lt;?Q, 16#F0, 16#90, 16#86, 16#96, ?Q&gt;&gt;} %% denarius
        |      ],
     1..|      lists:foreach(fun({CodePoint, UTF8}) -&gt;
     3..|          Expect = list_to_binary(xmerl_ucs:to_utf8(CodePoint)),
     3..|          Expect = decode(UTF8)
        |      end, Good),
        |  
     1..|      Bad = [
        |          %% 2nd, 3rd, or 4th byte of a multi-byte sequence w/o leading byte
        |          &lt;&lt;?Q, 16#80, ?Q&gt;&gt;,
        |          %% missing continuations, last byte in each should be 80-BF
        |          &lt;&lt;?Q, 16#C2, 16#7F, ?Q&gt;&gt;,
        |          &lt;&lt;?Q, 16#E0, 16#80,16#7F, ?Q&gt;&gt;,
        |          &lt;&lt;?Q, 16#F0, 16#80, 16#80, 16#7F, ?Q&gt;&gt;,
        |          %% we don't support code points &gt; 10FFFF per RFC 3629
        |          &lt;&lt;?Q, 16#F5, 16#80, 16#80, 16#80, ?Q&gt;&gt;
        |      ],
     1..|      lists:foreach(
        |        fun(X) -&gt;
     5..|                ok = try decode(X) catch invalid_utf8 -&gt; ok end,
        |                %% could be {ucs,{bad_utf8_character_code}} or
        |                %%          {json_encode,{bad_char,_}}
     5..|                {'EXIT', _} = (catch encode(X))
        |        end, Bad).
        |  
        |  inline_json_test() -&gt;
     1..|      ?assertEqual(&lt;&lt;"\"iodata iodata\""&gt;&gt;,
        |                   iolist_to_binary(
     1..|                     encode({json, [&lt;&lt;"\"iodata"&gt;&gt;, " iodata\""]}))),
     1..|      ?assertEqual({struct, [{&lt;&lt;"key"&gt;&gt;, &lt;&lt;"iodata iodata"&gt;&gt;}]},
        |                   decode(
        |                     encode({struct,
     1..|                             [{key, {json, [&lt;&lt;"\"iodata"&gt;&gt;, " iodata\""]}}]}))),
     1..|      ok.
        |  
        |  big_unicode_test() -&gt;
     1..|      UTF8Seq = list_to_binary(xmerl_ucs:to_utf8(16#0001d120)),
     1..|      ?assertEqual(
        |         &lt;&lt;"\"\\ud834\\udd20\""&gt;&gt;,
     1..|         iolist_to_binary(encode(UTF8Seq))),
     1..|      ?assertEqual(
        |         UTF8Seq,
     1..|         decode(iolist_to_binary(encode(UTF8Seq)))),
     1..|      ok.
        |  
        |  custom_decoder_test() -&gt;
     1..|      ?assertEqual(
        |         {struct, [{&lt;&lt;"key"&gt;&gt;, &lt;&lt;"value"&gt;&gt;}]},
     1..|         (decoder([]))("{\"key\": \"value\"}")),
     1..|      F = fun ({struct, [{&lt;&lt;"key"&gt;&gt;, &lt;&lt;"value"&gt;&gt;}]}) -&gt; win end,
     1..|      ?assertEqual(
        |         win,
     1..|         (decoder([{object_hook, F}]))("{\"key\": \"value\"}")),
     1..|      ok.
        |  
        |  atom_test() -&gt;
        |      %% JSON native atoms
     1..|      [begin
     3..|           ?assertEqual(A, decode(atom_to_list(A))),
     3..|           ?assertEqual(iolist_to_binary(atom_to_list(A)),
     3..|                        iolist_to_binary(encode(A)))
     1..|       end || A &lt;- [true, false, null]],
        |      %% Atom to string
     1..|      ?assertEqual(
        |         &lt;&lt;"\"foo\""&gt;&gt;,
     1..|         iolist_to_binary(encode(foo))),
     1..|      ?assertEqual(
        |         &lt;&lt;"\"\\ud834\\udd20\""&gt;&gt;,
     1..|         iolist_to_binary(encode(list_to_atom(xmerl_ucs:to_utf8(16#0001d120))))),
     1..|      ok.
        |  
        |  key_encode_test() -&gt;
        |      %% Some forms are accepted as keys that would not be strings in other
        |      %% cases
     1..|      ?assertEqual(
        |         &lt;&lt;"{\"foo\":1}"&gt;&gt;,
     1..|         iolist_to_binary(encode({struct, [{foo, 1}]}))),
     1..|      ?assertEqual(
        |         &lt;&lt;"{\"foo\":1}"&gt;&gt;,
     1..|         iolist_to_binary(encode({struct, [{&lt;&lt;"foo"&gt;&gt;, 1}]}))),
     1..|      ?assertEqual(
        |         &lt;&lt;"{\"foo\":1}"&gt;&gt;,
     1..|         iolist_to_binary(encode({struct, [{"foo", 1}]}))),
     1..|      ?assertEqual(
        |         &lt;&lt;"{\"\\ud834\\udd20\":1}"&gt;&gt;,
        |         iolist_to_binary(
     1..|           encode({struct, [{[16#0001d120], 1}]}))),
     1..|      ?assertEqual(
        |         &lt;&lt;"{\"1\":1}"&gt;&gt;,
     1..|         iolist_to_binary(encode({struct, [{1, 1}]}))),
     1..|      ok.
        |  
        |  unsafe_chars_test() -&gt;
     1..|      Chars = "\"\\\b\f\n\r\t",
     1..|      [begin
     7..|           ?assertEqual(false, json_string_is_safe([C])),
     7..|           ?assertEqual(false, json_bin_is_safe(&lt;&lt;C&gt;&gt;)),
     7..|           ?assertEqual(&lt;&lt;C&gt;&gt;, decode(encode(&lt;&lt;C&gt;&gt;)))
     1..|       end || C &lt;- Chars],
     1..|      ?assertEqual(
        |         false,
     1..|         json_string_is_safe([16#0001d120])),
     1..|      ?assertEqual(
        |         false,
     1..|         json_bin_is_safe(list_to_binary(xmerl_ucs:to_utf8(16#0001d120)))),
     1..|      ?assertEqual(
        |         [16#0001d120],
        |         xmerl_ucs:from_utf8(
        |           binary_to_list(
     1..|             decode(encode(list_to_atom(xmerl_ucs:to_utf8(16#0001d120))))))),
     1..|      ?assertEqual(
        |         false,
     1..|         json_string_is_safe([16#110000])),
     1..|      ?assertEqual(
        |         false,
     1..|         json_bin_is_safe(list_to_binary(xmerl_ucs:to_utf8([16#110000])))),
        |      %% solidus can be escaped but isn't unsafe by default
     1..|      ?assertEqual(
        |         &lt;&lt;"/"&gt;&gt;,
     1..|         decode(&lt;&lt;"\"\\/\""&gt;&gt;)),
     1..|      ok.
        |  
        |  int_test() -&gt;
     1..|      ?assertEqual(0, decode("0")),
     1..|      ?assertEqual(1, decode("1")),
     1..|      ?assertEqual(11, decode("11")),
     1..|      ok.
        |  
        |  float_fallback_test() -&gt;
     1..|      ?assertEqual(&lt;&lt;"-2147483649.0"&gt;&gt;, iolist_to_binary(encode(-2147483649))),
     1..|      ?assertEqual(&lt;&lt;"2147483648.0"&gt;&gt;, iolist_to_binary(encode(2147483648))),
     1..|      ok.
        |  
        |  handler_test() -&gt;
     1..|      ?assertEqual(
        |         {'EXIT',{json_encode,{bad_term,{}}}},
     1..|         catch encode({})),
     1..|      F = fun ({}) -&gt; [] end,
     1..|      ?assertEqual(
        |         &lt;&lt;"[]"&gt;&gt;,
     1..|         iolist_to_binary((encoder([{handler, F}]))({}))),
     1..|      ok.
        |  
        |  -endif.
</pre>
</body>
</html>
