<html>
<head><title>.eunit/reloader.COVER.html</title></head><body bgcolor=white text=black>
<pre>
File generated from /Users/seb/Documents/part2project/app/deps/mochiweb/.eunit/reloader.erl by COVER 2010-10-28 at 14:19:51

****************************************************************************

        |  %% @copyright 2007 Mochi Media, Inc.
        |  %% @author Matthew Dempsky &lt;matthew@mochimedia.com&gt;
        |  %%
        |  %% @doc Erlang module for automatically reloading modified modules
        |  %% during development.
        |  
        |  -module(reloader).
        |  -author("Matthew Dempsky &lt;matthew@mochimedia.com&gt;").
        |  
        |  -include_lib("kernel/include/file.hrl").
        |  
        |  -behaviour(gen_server).
        |  -export([start/0, start_link/0]).
        |  -export([stop/0]).
        |  -export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).
        |  -export([all_changed/0]).
        |  -export([is_changed/1]).
        |  -export([reload_modules/1]).
        |  -record(state, {last, tref}).
        |  
        |  %% External API
        |  
        |  %% @spec start() -&gt; ServerRet
        |  %% @doc Start the reloader.
        |  start() -&gt;
<font color=red>     0..|      gen_server:start({local, ?MODULE}, ?MODULE, [], []).</font>
        |  
        |  %% @spec start_link() -&gt; ServerRet
        |  %% @doc Start the reloader.
        |  start_link() -&gt;
<font color=red>     0..|      gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).</font>
        |  
        |  %% @spec stop() -&gt; ok
        |  %% @doc Stop the reloader.
        |  stop() -&gt;
<font color=red>     0..|      gen_server:call(?MODULE, stop).</font>
        |  
        |  %% gen_server callbacks
        |  
        |  %% @spec init([]) -&gt; {ok, State}
        |  %% @doc gen_server init, opens the server in an initial state.
        |  init([]) -&gt;
<font color=red>     0..|      {ok, TRef} = timer:send_interval(timer:seconds(1), doit),</font>
<font color=red>     0..|      {ok, #state{last = stamp(), tref = TRef}}.</font>
        |  
        |  %% @spec handle_call(Args, From, State) -&gt; tuple()
        |  %% @doc gen_server callback.
        |  handle_call(stop, _From, State) -&gt;
<font color=red>     0..|      {stop, shutdown, stopped, State};</font>
        |  handle_call(_Req, _From, State) -&gt;
<font color=red>     0..|      {reply, {error, badrequest}, State}.</font>
        |  
        |  %% @spec handle_cast(Cast, State) -&gt; tuple()
        |  %% @doc gen_server callback.
        |  handle_cast(_Req, State) -&gt;
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  %% @spec handle_info(Info, State) -&gt; tuple()
        |  %% @doc gen_server callback.
        |  handle_info(doit, State) -&gt;
<font color=red>     0..|      Now = stamp(),</font>
<font color=red>     0..|      doit(State#state.last, Now),</font>
<font color=red>     0..|      {noreply, State#state{last = Now}};</font>
        |  handle_info(_Info, State) -&gt;
<font color=red>     0..|      {noreply, State}.</font>
        |  
        |  %% @spec terminate(Reason, State) -&gt; ok
        |  %% @doc gen_server termination callback.
        |  terminate(_Reason, State) -&gt;
<font color=red>     0..|      {ok, cancel} = timer:cancel(State#state.tref),</font>
<font color=red>     0..|      ok.</font>
        |  
        |  
        |  %% @spec code_change(_OldVsn, State, _Extra) -&gt; State
        |  %% @doc gen_server code_change callback (trivial).
        |  code_change(_Vsn, State, _Extra) -&gt;
<font color=red>     0..|      {ok, State}.</font>
        |  
        |  %% @spec reload_modules([atom()]) -&gt; [{module, atom()} | {error, term()}]
        |  %% @doc code:purge/1 and code:load_file/1 the given list of modules in order,
        |  %%      return the results of code:load_file/1.
        |  reload_modules(Modules) -&gt;
<font color=red>     0..|      [begin code:purge(M), code:load_file(M) end || M &lt;- Modules].</font>
        |  
        |  %% @spec all_changed() -&gt; [atom()]
        |  %% @doc Return a list of beam modules that have changed.
        |  all_changed() -&gt;
<font color=red>     0..|      [M || {M, Fn} &lt;- code:all_loaded(), is_list(Fn), is_changed(M)].</font>
        |  
        |  %% @spec is_changed(atom()) -&gt; boolean()
        |  %% @doc true if the loaded module is a beam with a vsn attribute
        |  %%      and does not match the on-disk beam file, returns false otherwise.
        |  is_changed(M) -&gt;
<font color=red>     0..|      try</font>
<font color=red>     0..|          module_vsn(M:module_info()) =/= module_vsn(code:get_object_code(M))</font>
        |      catch _:_ -&gt;
<font color=red>     0..|              false</font>
        |      end.
        |  
        |  %% Internal API
        |  
        |  module_vsn({M, Beam, _Fn}) -&gt;
<font color=red>     0..|      {ok, {M, Vsn}} = beam_lib:version(Beam),</font>
<font color=red>     0..|      Vsn;</font>
        |  module_vsn(L) when is_list(L) -&gt;
<font color=red>     0..|      {_, Attrs} = lists:keyfind(attributes, 1, L),</font>
<font color=red>     0..|      {_, Vsn} = lists:keyfind(vsn, 1, Attrs),</font>
<font color=red>     0..|      Vsn.</font>
        |  
        |  doit(From, To) -&gt;
<font color=red>     0..|      [case file:read_file_info(Filename) of</font>
        |           {ok, #file_info{mtime = Mtime}} when Mtime &gt;= From, Mtime &lt; To -&gt;
<font color=red>     0..|               reload(Module);</font>
        |           {ok, _} -&gt;
<font color=red>     0..|               unmodified;</font>
        |           {error, enoent} -&gt;
        |               %% The Erlang compiler deletes existing .beam files if
        |               %% recompiling fails.  Maybe it's worth spitting out a
        |               %% warning here, but I'd want to limit it to just once.
<font color=red>     0..|               gone;</font>
        |           {error, Reason} -&gt;
<font color=red>     0..|               io:format("Error reading ~s's file info: ~p~n",</font>
        |                         [Filename, Reason]),
<font color=red>     0..|               error</font>
<font color=red>     0..|       end || {Module, Filename} &lt;- code:all_loaded(), is_list(Filename)].</font>
        |  
        |  reload(Module) -&gt;
<font color=red>     0..|      io:format("Reloading ~p ...", [Module]),</font>
<font color=red>     0..|      code:purge(Module),</font>
<font color=red>     0..|      case code:load_file(Module) of</font>
        |          {module, Module} -&gt;
<font color=red>     0..|              io:format(" ok.~n"),</font>
<font color=red>     0..|              case erlang:function_exported(Module, test, 0) of</font>
        |                  true -&gt;
<font color=red>     0..|                      io:format(" - Calling ~p:test() ...", [Module]),</font>
<font color=red>     0..|                      case catch Module:test() of</font>
        |                          ok -&gt;
<font color=red>     0..|                              io:format(" ok.~n"),</font>
<font color=red>     0..|                              reload;</font>
        |                          Reason -&gt;
<font color=red>     0..|                              io:format(" fail: ~p.~n", [Reason]),</font>
<font color=red>     0..|                              reload_but_test_failed</font>
        |                      end;
        |                  false -&gt;
<font color=red>     0..|                      reload</font>
        |              end;
        |          {error, Reason} -&gt;
<font color=red>     0..|              io:format(" fail: ~p.~n", [Reason]),</font>
<font color=red>     0..|              error</font>
        |      end.
        |  
        |  
        |  stamp() -&gt;
<font color=red>     0..|      erlang:localtime().</font>
        |  
        |  %%
        |  %% Tests
        |  %%
        |  -include_lib("eunit/include/eunit.hrl").
        |  -ifdef(TEST).
        |  -endif.
</pre>
</body>
</html>
