<html>
<head><title>.eunit/mochifmt.COVER.html</title></head><body bgcolor=white text=black>
<pre>
File generated from /Users/seb/Documents/part2project/app/deps/mochiweb/.eunit/mochifmt.erl by COVER 2010-10-28 at 14:19:47

****************************************************************************

        |  %% @author Bob Ippolito &lt;bob@mochimedia.com&gt;
        |  %% @copyright 2008 Mochi Media, Inc.
        |  
        |  %% @doc String Formatting for Erlang, inspired by Python 2.6
        |  %%      (&lt;a href="http://www.python.org/dev/peps/pep-3101/"&gt;PEP 3101&lt;/a&gt;).
        |  %%
        |  -module(mochifmt).
        |  -author('bob@mochimedia.com').
        |  -export([format/2, format_field/2, convert_field/2, get_value/2, get_field/2]).
        |  -export([tokenize/1, format/3, get_field/3, format_field/3]).
        |  -export([bformat/2, bformat/3]).
        |  -export([f/2, f/3]).
        |  
        |  -record(conversion, {length, precision, ctype, align, fill_char, sign}).
        |  
        |  %% @spec tokenize(S::string()) -&gt; tokens()
        |  %% @doc Tokenize a format string into mochifmt's internal format.
        |  tokenize(S) -&gt;
    34..|      {?MODULE, tokenize(S, "", [])}.
        |  
        |  %% @spec convert_field(Arg, Conversion::conversion()) -&gt; term()
        |  %% @doc Process Arg according to the given explicit conversion specifier.
        |  convert_field(Arg, "") -&gt;
    43..|      Arg;
        |  convert_field(Arg, "r") -&gt;
     2..|      repr(Arg);
        |  convert_field(Arg, "s") -&gt;
<font color=red>     0..|      str(Arg).</font>
        |  
        |  %% @spec get_value(Key::string(), Args::args()) -&gt; term()
        |  %% @doc Get the Key from Args. If Args is a tuple then convert Key to
        |  %%      an integer and get element(1 + Key, Args). If Args is a list and Key
        |  %%      can be parsed as an integer then use lists:nth(1 + Key, Args),
        |  %%      otherwise try and look for Key in Args as a proplist, converting
        |  %%      Key to an atom or binary if necessary.
        |  get_value(Key, Args) when is_tuple(Args) -&gt;
    39..|      element(1 + list_to_integer(Key), Args);
        |  get_value(Key, Args) when is_list(Args) -&gt;
    16..|      try lists:nth(1 + list_to_integer(Key), Args)
        |      catch error:_ -&gt;
     4..|              {_K, V} = proplist_lookup(Key, Args),
     4..|              V
        |      end.
        |  
        |  %% @spec get_field(Key::string(), Args) -&gt; term()
        |  %% @doc Consecutively call get_value/2 on parts of Key delimited by ".",
        |  %%      replacing Args with the result of the previous get_value. This
        |  %%      is used to implement formats such as {0.0}.
        |  get_field(Key, Args) -&gt;
    39..|      get_field(Key, Args, ?MODULE).
        |  
        |  %% @spec get_field(Key::string(), Args, Module) -&gt; term()
        |  %% @doc Consecutively call Module:get_value/2 on parts of Key delimited by ".",
        |  %%      replacing Args with the result of the previous get_value. This
        |  %%      is used to implement formats such as {0.0}.
        |  get_field(Key, Args, Module) -&gt;
    59..|      {Name, Next} = lists:splitwith(fun (C) -&gt; C =/= $. end, Key),
    59..|      Res = try Module:get_value(Name, Args)
<font color=red>     0..|            catch error:undef -&gt; get_value(Name, Args) end,</font>
    59..|      case Next of
        |          "" -&gt;
    45..|              Res;
        |          "." ++ S1 -&gt;
    14..|              get_field(S1, Res, Module)
        |      end.
        |  
        |  %% @spec format(Format::string(), Args) -&gt; iolist()
        |  %% @doc Format Args with Format.
        |  format(Format, Args) -&gt;
    23..|      format(Format, Args, ?MODULE).
        |  
        |  %% @spec format(Format::string(), Args, Module) -&gt; iolist()
        |  %% @doc Format Args with Format using Module.
        |  format({?MODULE, Parts}, Args, Module) -&gt;
    31..|      format2(Parts, Args, Module, []);
        |  format(S, Args, Module) -&gt;
    31..|      format(tokenize(S), Args, Module).
        |  
        |  %% @spec format_field(Arg, Format) -&gt; iolist()
        |  %% @doc Format Arg with Format.
        |  format_field(Arg, Format) -&gt;
    39..|      format_field(Arg, Format, ?MODULE).
        |  
        |  %% @spec format_field(Arg, Format, _Module) -&gt; iolist()
        |  %% @doc Format Arg with Format.
        |  format_field(Arg, Format, _Module) -&gt;
    45..|      F = default_ctype(Arg, parse_std_conversion(Format)),
    45..|      fix_padding(fix_sign(convert2(Arg, F), F), F).
        |  
        |  %% @spec f(Format::string(), Args) -&gt; string()
        |  %% @doc Format Args with Format and return a string().
        |  f(Format, Args) -&gt;
<font color=red>     0..|      f(Format, Args, ?MODULE).</font>
        |  
        |  %% @spec f(Format::string(), Args, Module) -&gt; string()
        |  %% @doc Format Args with Format using Module and return a string().
        |  f(Format, Args, Module) -&gt;
    45..|      case lists:member(${, Format) of
        |          true -&gt;
     5..|              binary_to_list(bformat(Format, Args, Module));
        |          false -&gt;
    40..|              Format
        |      end.
        |  
        |  %% @spec bformat(Format::string(), Args) -&gt; binary()
        |  %% @doc Format Args with Format and return a binary().
        |  bformat(Format, Args) -&gt;
    23..|      iolist_to_binary(format(Format, Args)).
        |  
        |  %% @spec bformat(Format::string(), Args, Module) -&gt; binary()
        |  %% @doc Format Args with Format using Module and return a binary().
        |  bformat(Format, Args, Module) -&gt;
     8..|      iolist_to_binary(format(Format, Args, Module)).
        |  
        |  %% Internal API
        |  
        |  add_raw("", Acc) -&gt;
    63..|      Acc;
        |  add_raw(S, Acc) -&gt;
    18..|      [{raw, lists:reverse(S)} | Acc].
        |  
        |  tokenize([], S, Acc) -&gt;
    34..|      lists:reverse(add_raw(S, Acc));
        |  tokenize("{{" ++ Rest, S, Acc) -&gt;
<font color=red>     0..|      tokenize(Rest, "{" ++ S, Acc);</font>
        |  tokenize("{" ++ Rest, S, Acc) -&gt;
    47..|      {Format, Rest1} = tokenize_format(Rest),
    47..|      tokenize(Rest1, "", [{format, make_format(Format)} | add_raw(S, Acc)]);
        |  tokenize("}}" ++ Rest, S, Acc) -&gt;
<font color=red>     0..|      tokenize(Rest, "}" ++ S, Acc);</font>
        |  tokenize([C | Rest], S, Acc) -&gt;
    26..|      tokenize(Rest, [C | S], Acc).
        |  
        |  tokenize_format(S) -&gt;
    47..|      tokenize_format(S, 1, []).
        |  
        |  tokenize_format("}" ++ Rest, 1, Acc) -&gt;
    47..|      {lists:reverse(Acc), Rest};
        |  tokenize_format("}" ++ Rest, N, Acc) -&gt;
     5..|      tokenize_format(Rest, N - 1, "}" ++ Acc);
        |  tokenize_format("{" ++ Rest, N, Acc) -&gt;
     5..|      tokenize_format(Rest, 1 + N, "{" ++ Acc);
        |  tokenize_format([C | Rest], N, Acc) -&gt;
   175..|      tokenize_format(Rest, N, [C | Acc]).
        |  
        |  make_format(S) -&gt;
    47..|      {Name0, Spec} = case lists:splitwith(fun (C) -&gt; C =/= $: end, S) of
        |                          {_, ""} -&gt;
    25..|                              {S, ""};
        |                          {SN, ":" ++ SS} -&gt;
    22..|                              {SN, SS}
        |                      end,
    47..|      {Name, Transform} = case lists:splitwith(fun (C) -&gt; C =/= $! end, Name0) of
        |                              {_, ""} -&gt;
    45..|                                  {Name0, ""};
        |                              {TN, "!" ++ TT} -&gt;
     2..|                                  {TN, TT}
        |                          end,
    47..|      {Name, Transform, Spec}.
        |  
        |  proplist_lookup(S, P) -&gt;
     4..|      A = try list_to_existing_atom(S)
<font color=red>     0..|          catch error:_ -&gt; make_ref() end,</font>
     4..|      B = try list_to_binary(S)
<font color=red>     0..|          catch error:_ -&gt; make_ref() end,</font>
     4..|      proplist_lookup2({S, A, B}, P).
        |  
        |  proplist_lookup2({KS, KA, KB}, [{K, V} | _])
        |    when KS =:= K orelse KA =:= K orelse KB =:= K -&gt;
     4..|      {K, V};
        |  proplist_lookup2(Keys, [_ | Rest]) -&gt;
<font color=red>     0..|      proplist_lookup2(Keys, Rest).</font>
        |  
        |  format2([], _Args, _Module, Acc) -&gt;
    31..|      lists:reverse(Acc);
        |  format2([{raw, S} | Rest], Args, Module, Acc) -&gt;
    15..|      format2(Rest, Args, Module, [S | Acc]);
        |  format2([{format, {Key, Convert, Format0}} | Rest], Args, Module, Acc) -&gt;
    45..|      Format = f(Format0, Args, Module),
    45..|      V = case Module of
        |              ?MODULE -&gt;
    39..|                  V0 = get_field(Key, Args),
    39..|                  V1 = convert_field(V0, Convert),
    39..|                  format_field(V1, Format);
        |              _ -&gt;
     6..|                  V0 = try Module:get_field(Key, Args)
     4..|                       catch error:undef -&gt; get_field(Key, Args, Module) end,
     6..|                  V1 = try Module:convert_field(V0, Convert)
     4..|                       catch error:undef -&gt; convert_field(V0, Convert) end,
     6..|                  try Module:format_field(V1, Format)
     4..|                  catch error:undef -&gt; format_field(V1, Format, Module) end
        |          end,
    45..|      format2(Rest, Args, Module, [V | Acc]).
        |  
        |  default_ctype(_Arg, C=#conversion{ctype=N}) when N =/= undefined -&gt;
    11..|      C;
        |  default_ctype(Arg, C) when is_integer(Arg) -&gt;
    20..|      C#conversion{ctype=decimal};
        |  default_ctype(Arg, C) when is_float(Arg) -&gt;
     1..|      C#conversion{ctype=general};
        |  default_ctype(_Arg, C) -&gt;
    13..|      C#conversion{ctype=string}.
        |  
        |  fix_padding(Arg, #conversion{length=undefined}) -&gt;
    34..|      Arg;
        |  fix_padding(Arg, F=#conversion{length=Length, fill_char=Fill0, align=Align0,
        |                                 ctype=Type}) -&gt;
    11..|      Padding = Length - iolist_size(Arg),
    11..|      Fill = case Fill0 of
        |                 undefined -&gt;
     5..|                     $\s;
        |                 _ -&gt;
     6..|                     Fill0
        |             end,
    11..|      Align = case Align0 of
        |                  undefined -&gt;
     5..|                      case Type of
        |                          string -&gt;
     2..|                              left;
        |                          _ -&gt;
     3..|                              right
        |                      end;
        |                  _ -&gt;
     6..|                      Align0
        |              end,
    11..|      case Padding &gt; 0 of
        |          true -&gt;
     9..|              do_padding(Arg, Padding, Fill, Align, F);
        |          false -&gt;
     2..|              Arg
        |      end.
        |  
        |  do_padding(Arg, Padding, Fill, right, _F) -&gt;
     3..|      [lists:duplicate(Padding, Fill), Arg];
        |  do_padding(Arg, Padding, Fill, center, _F) -&gt;
<font color=red>     0..|      LPadding = lists:duplicate(Padding div 2, Fill),</font>
<font color=red>     0..|      RPadding = case Padding band 1 of</font>
        |                     1 -&gt;
<font color=red>     0..|                         [Fill | LPadding];</font>
        |                     _ -&gt;
<font color=red>     0..|                         LPadding</font>
        |                 end,
<font color=red>     0..|      [LPadding, Arg, RPadding];</font>
        |  do_padding([$- | Arg], Padding, Fill, sign_right, _F) -&gt;
<font color=red>     0..|      [[$- | lists:duplicate(Padding, Fill)], Arg];</font>
        |  do_padding(Arg, Padding, Fill, sign_right, #conversion{sign=$-}) -&gt;
<font color=red>     0..|      [lists:duplicate(Padding, Fill), Arg];</font>
        |  do_padding([S | Arg], Padding, Fill, sign_right, #conversion{sign=S}) -&gt;
<font color=red>     0..|      [[S | lists:duplicate(Padding, Fill)], Arg];</font>
        |  do_padding(Arg, Padding, Fill, sign_right, #conversion{sign=undefined}) -&gt;
     4..|      [lists:duplicate(Padding, Fill), Arg];
        |  do_padding(Arg, Padding, Fill, left, _F) -&gt;
     2..|      [Arg | lists:duplicate(Padding, Fill)].
        |  
        |  fix_sign(Arg, #conversion{sign=$+}) when Arg &gt;= 0 -&gt;
<font color=red>     0..|      [$+, Arg];</font>
        |  fix_sign(Arg, #conversion{sign=$\s}) when Arg &gt;= 0 -&gt;
<font color=red>     0..|      [$\s, Arg];</font>
        |  fix_sign(Arg, _F) -&gt;
    45..|      Arg.
        |  
<font color=red>     0..|  ctype($\%) -&gt; percent;</font>
<font color=red>     0..|  ctype($s) -&gt; string;</font>
     5..|  ctype($b) -&gt; bin;
     1..|  ctype($o) -&gt; oct;
     2..|  ctype($X) -&gt; upper_hex;
     1..|  ctype($x) -&gt; hex;
     2..|  ctype($c) -&gt; char;
<font color=red>     0..|  ctype($d) -&gt; decimal;</font>
<font color=red>     0..|  ctype($g) -&gt; general;</font>
<font color=red>     0..|  ctype($f) -&gt; fixed;</font>
<font color=red>     0..|  ctype($e) -&gt; exp.</font>
        |  
<font color=red>     0..|  align($&lt;) -&gt; left;</font>
<font color=red>     0..|  align($&gt;) -&gt; right;</font>
<font color=red>     0..|  align($^) -&gt; center;</font>
<font color=red>     0..|  align($=) -&gt; sign_right.</font>
        |  
        |  convert2(Arg, F=#conversion{ctype=percent}) -&gt;
<font color=red>     0..|      [convert2(100.0 * Arg, F#conversion{ctype=fixed}), $\%];</font>
        |  convert2(Arg, #conversion{ctype=string}) -&gt;
    13..|      str(Arg);
        |  convert2(Arg, #conversion{ctype=bin}) -&gt;
     5..|      erlang:integer_to_list(Arg, 2);
        |  convert2(Arg, #conversion{ctype=oct}) -&gt;
     1..|      erlang:integer_to_list(Arg, 8);
        |  convert2(Arg, #conversion{ctype=upper_hex}) -&gt;
     2..|      erlang:integer_to_list(Arg, 16);
        |  convert2(Arg, #conversion{ctype=hex}) -&gt;
     1..|      string:to_lower(erlang:integer_to_list(Arg, 16));
        |  convert2(Arg, #conversion{ctype=char}) when Arg &lt; 16#80 -&gt;
     1..|      [Arg];
        |  convert2(Arg, #conversion{ctype=char}) -&gt;
     1..|      xmerl_ucs:to_utf8(Arg);
        |  convert2(Arg, #conversion{ctype=decimal}) -&gt;
    20..|      integer_to_list(Arg);
        |  convert2(Arg, #conversion{ctype=general, precision=undefined}) -&gt;
     1..|      try mochinum:digits(Arg)
<font color=red>     0..|      catch error:undef -&gt; io_lib:format("~g", [Arg]) end;</font>
        |  convert2(Arg, #conversion{ctype=fixed, precision=undefined}) -&gt;
<font color=red>     0..|      io_lib:format("~f", [Arg]);</font>
        |  convert2(Arg, #conversion{ctype=exp, precision=undefined}) -&gt;
<font color=red>     0..|      io_lib:format("~e", [Arg]);</font>
        |  convert2(Arg, #conversion{ctype=general, precision=P}) -&gt;
<font color=red>     0..|      io_lib:format("~." ++ integer_to_list(P) ++ "g", [Arg]);</font>
        |  convert2(Arg, #conversion{ctype=fixed, precision=P}) -&gt;
<font color=red>     0..|      io_lib:format("~." ++ integer_to_list(P) ++ "f", [Arg]);</font>
        |  convert2(Arg, #conversion{ctype=exp, precision=P}) -&gt;
<font color=red>     0..|      io_lib:format("~." ++ integer_to_list(P) ++ "e", [Arg]).</font>
        |  
        |  str(A) when is_atom(A) -&gt;
     6..|      atom_to_list(A);
        |  str(I) when is_integer(I) -&gt;
<font color=red>     0..|      integer_to_list(I);</font>
        |  str(F) when is_float(F) -&gt;
<font color=red>     0..|      try mochinum:digits(F)</font>
<font color=red>     0..|      catch error:undef -&gt; io_lib:format("~g", [F]) end;</font>
        |  str(L) when is_list(L) -&gt;
     6..|      L;
        |  str(B) when is_binary(B) -&gt;
     1..|      B;
        |  str(P) -&gt;
<font color=red>     0..|      repr(P).</font>
        |  
        |  repr(P) when is_float(P) -&gt;
<font color=red>     0..|      try mochinum:digits(P)</font>
<font color=red>     0..|      catch error:undef -&gt; float_to_list(P) end;</font>
        |  repr(P) -&gt;
     2..|      io_lib:format("~p", [P]).
        |  
        |  parse_std_conversion(S) -&gt;
    45..|      parse_std_conversion(S, #conversion{}).
        |  
        |  parse_std_conversion("", Acc) -&gt;
    45..|      Acc;
        |  parse_std_conversion([Fill, Align | Spec], Acc)
        |    when Align =:= $&lt; orelse Align =:= $&gt; orelse Align =:= $= orelse Align =:= $^ -&gt;
<font color=red>     0..|      parse_std_conversion(Spec, Acc#conversion{fill_char=Fill,</font>
        |                                                align=align(Align)});
        |  parse_std_conversion([Align | Spec], Acc)
        |    when Align =:= $&lt; orelse Align =:= $&gt; orelse Align =:= $= orelse Align =:= $^ -&gt;
<font color=red>     0..|      parse_std_conversion(Spec, Acc#conversion{align=align(Align)});</font>
        |  parse_std_conversion([Sign | Spec], Acc)
        |    when Sign =:= $+ orelse Sign =:= $- orelse Sign =:= $\s -&gt;
<font color=red>     0..|      parse_std_conversion(Spec, Acc#conversion{sign=Sign});</font>
        |  parse_std_conversion("0" ++ Spec, Acc) -&gt;
     6..|      Align = case Acc#conversion.align of
        |                  undefined -&gt;
     6..|                      sign_right;
        |                  A -&gt;
<font color=red>     0..|                      A</font>
        |              end,
     6..|      parse_std_conversion(Spec, Acc#conversion{fill_char=$0, align=Align});
        |  parse_std_conversion(Spec=[D|_], Acc) when D &gt;= $0 andalso D =&lt; $9 -&gt;
    11..|      {W, Spec1} = lists:splitwith(fun (C) -&gt; C &gt;= $0 andalso C =&lt; $9 end, Spec),
    11..|      parse_std_conversion(Spec1, Acc#conversion{length=list_to_integer(W)});
        |  parse_std_conversion([$. | Spec], Acc) -&gt;
<font color=red>     0..|      case lists:splitwith(fun (C) -&gt; C &gt;= $0 andalso C =&lt; $9 end, Spec) of</font>
        |          {"", Spec1} -&gt;
<font color=red>     0..|              parse_std_conversion(Spec1, Acc);</font>
        |          {P, Spec1} -&gt;
<font color=red>     0..|              parse_std_conversion(Spec1,</font>
        |                                   Acc#conversion{precision=list_to_integer(P)})
        |      end;
        |  parse_std_conversion([Type], Acc) -&gt;
    11..|      parse_std_conversion("", Acc#conversion{ctype=ctype(Type)}).
        |  
        |  
        |  %%
        |  %% Tests
        |  %%
        |  -include_lib("eunit/include/eunit.hrl").
        |  -ifdef(TEST).
        |  
        |  tokenize_test() -&gt;
     1..|      {?MODULE, [{raw, "ABC"}]} = tokenize("ABC"),
     1..|      {?MODULE, [{format, {"0", "", ""}}]} = tokenize("{0}"),
     1..|      {?MODULE, [{raw, "ABC"}, {format, {"1", "", ""}}, {raw, "DEF"}]} =
        |          tokenize("ABC{1}DEF"),
     1..|      ok.
        |  
        |  format_test() -&gt;
     1..|      &lt;&lt;"  -4"&gt;&gt; = bformat("{0:4}", [-4]),
     1..|      &lt;&lt;"   4"&gt;&gt; = bformat("{0:4}", [4]),
     1..|      &lt;&lt;"   4"&gt;&gt; = bformat("{0:{0}}", [4]),
     1..|      &lt;&lt;"4   "&gt;&gt; = bformat("{0:4}", ["4"]),
     1..|      &lt;&lt;"4   "&gt;&gt; = bformat("{0:{0}}", ["4"]),
     1..|      &lt;&lt;"1.2yoDEF"&gt;&gt; = bformat("{2}{0}{1}{3}", {yo, "DE", 1.2, &lt;&lt;"F"&gt;&gt;}),
     1..|      &lt;&lt;"cafebabe"&gt;&gt; = bformat("{0:x}", {16#cafebabe}),
     1..|      &lt;&lt;"CAFEBABE"&gt;&gt; = bformat("{0:X}", {16#cafebabe}),
     1..|      &lt;&lt;"CAFEBABE"&gt;&gt; = bformat("{0:X}", {16#cafebabe}),
     1..|      &lt;&lt;"755"&gt;&gt; = bformat("{0:o}", {8#755}),
     1..|      &lt;&lt;"a"&gt;&gt; = bformat("{0:c}", {97}),
        |      %% Horizontal ellipsis
     1..|      &lt;&lt;226, 128, 166&gt;&gt; = bformat("{0:c}", {16#2026}),
     1..|      &lt;&lt;"11"&gt;&gt; = bformat("{0:b}", {3}),
     1..|      &lt;&lt;"11"&gt;&gt; = bformat("{0:b}", [3]),
     1..|      &lt;&lt;"11"&gt;&gt; = bformat("{three:b}", [{three, 3}]),
     1..|      &lt;&lt;"11"&gt;&gt; = bformat("{three:b}", [{"three", 3}]),
     1..|      &lt;&lt;"11"&gt;&gt; = bformat("{three:b}", [{&lt;&lt;"three"&gt;&gt;, 3}]),
     1..|      &lt;&lt;"\"foo\""&gt;&gt; = bformat("{0!r}", {"foo"}),
     1..|      &lt;&lt;"2008-5-4"&gt;&gt; = bformat("{0.0}-{0.1}-{0.2}", {{2008,5,4}}),
     1..|      &lt;&lt;"2008-05-04"&gt;&gt; = bformat("{0.0:04}-{0.1:02}-{0.2:02}", {{2008,5,4}}),
     1..|      &lt;&lt;"foo6bar-6"&gt;&gt; = bformat("foo{1}{0}-{1}", {bar, 6}),
     1..|      &lt;&lt;"-'atom test'-"&gt;&gt; = bformat("-{arg!r}-", [{arg, 'atom test'}]),
     1..|      &lt;&lt;"2008-05-04"&gt;&gt; = bformat("{0.0:0{1.0}}-{0.1:0{1.1}}-{0.2:0{1.2}}",
        |                                 {{2008,5,4}, {4, 2, 2}}),
     1..|      ok.
        |  
        |  std_test() -&gt;
     1..|      M = mochifmt_std:new(),
     1..|      &lt;&lt;"01"&gt;&gt; = bformat("{0}{1}", [0, 1], M),
     1..|      ok.
        |  
        |  records_test() -&gt;
     1..|      M = mochifmt_records:new([{conversion, record_info(fields, conversion)}]),
     1..|      R = #conversion{length=long, precision=hard, sign=peace},
     1..|      long = M:get_value("length", R),
     1..|      hard = M:get_value("precision", R),
     1..|      peace = M:get_value("sign", R),
     1..|      &lt;&lt;"long hard"&gt;&gt; = bformat("{length} {precision}", R, M),
     1..|      &lt;&lt;"long hard"&gt;&gt; = bformat("{0.length} {0.precision}", [R], M),
     1..|      ok.
        |  
        |  -endif.
</pre>
</body>
</html>
